
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>filter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Lands-Horizon-Corp/golang-filtering/filter/doc.go (100.0%)</option>
				
				<option value="file1">github.com/Lands-Horizon-Corp/golang-filtering/filter/gorm.go (67.6%)</option>
				
				<option value="file2">github.com/Lands-Horizon-Corp/golang-filtering/filter/helpers.go (74.4%)</option>
				
				<option value="file3">github.com/Lands-Horizon-Corp/golang-filtering/filter/hybrid.go (53.5%)</option>
				
				<option value="file4">github.com/Lands-Horizon-Corp/golang-filtering/filter/query.go (71.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package filter provides utilities for filtering, sorting, and paginating data sets.
package filter

// Handler is the main struct that handles filtering operations for a specific data type T.
type Handler[T any] struct {
        getters map[string]func(*T) any
}

type GolangFilteringConfig struct {
        MaxDepth *int
}

// New creates a new filter handler that automatically generates getters using reflection
func NewFilter[T any](config GolangFilteringConfig) *Handler[T] <span class="cov8" title="1">{
        depth := 1
        if config.MaxDepth != nil </span><span class="cov8" title="1">{
                depth = *config.MaxDepth
        }</span>
        <span class="cov8" title="1">getters := generateGetters[T](depth)
        return &amp;Handler[T]{
                getters: getters,
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package filter

import (
        "bytes"
        "encoding/csv"
        "fmt"
        "sort"
        "strings"
        "time"

        "gorm.io/gorm"
)

// ApplyPresetConditions applies struct fields as WHERE conditions to the db query.
// This is a helper to easily apply preset filters from a struct.
//
// Example usage:
//
//        type AccountTag struct {
//            OrganizationID uint
//            BranchID       uint
//        }
//
//        tag := &amp;AccountTag{OrganizationID: 1, BranchID: 2}
//        db = filter.ApplyPresetConditions(db, tag)
//        result, err := handler.DataGorm(db, filterRoot, pageIndex, pageSize)
func ApplyPresetConditions(db *gorm.DB, conditions any) *gorm.DB <span class="cov8" title="1">{
        if conditions == nil </span><span class="cov0" title="0">{
                return db
        }</span>
        <span class="cov8" title="1">return db.Where(conditions)</span>
}

// DataGorm performs database-level filtering using GORM queries.
// It generates SQL WHERE clauses based on the filter configuration and returns paginated results.
// The db parameter can have existing WHERE conditions (e.g., organization_id, branch_id),
// and DataGorm will apply additional filters from filterRoot on top of those.
//
// Example with preset conditions using struct:
//
//        type AccountTag struct {
//            OrganizationID uint
//            BranchID       uint
//        }
//        tag := &amp;AccountTag{OrganizationID: user.OrganizationID, BranchID: *user.BranchID}
//        db = filter.ApplyPresetConditions(db, tag)
//        result, err := handler.DataGorm(db, filterRoot, pageIndex, pageSize)
//
// Example with preset conditions using Where:
//
//        presetDB := db.Where("organization_id = ? AND branch_id = ?", orgID, branchID)
//        result, err := handler.DataGorm(presetDB, filterRoot, pageIndex, pageSize)
func (f *Handler[T]) DataGorm(
        db *gorm.DB,
        filterRoot Root,
        pageIndex int,
        pageSize int,
) (*PaginationResult[T], error) <span class="cov8" title="1">{
        result := PaginationResult[T]{
                PageIndex: pageIndex,
                PageSize:  pageSize,
        }

        // Set defaults if not provided - use 0-based indexing
        if result.PageIndex &lt; 0 </span><span class="cov0" title="0">{
                result.PageIndex = 0
        }</span>
        <span class="cov8" title="1">if result.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                result.PageSize = 30
        }</span>

        // Build the query - db may already have WHERE conditions, they will be preserved
        <span class="cov8" title="1">query := db.Model(new(T))

        // Auto-join related tables based on field filters and sort fields
        query = f.autoJoinRelatedTables(query, filterRoot.FieldFilters, filterRoot.SortFields)

        // Apply preloads (GORM only feature)
        if len(filterRoot.Preload) &gt; 0 </span><span class="cov8" title="1">{
                for _, preloadField := range filterRoot.Preload </span><span class="cov8" title="1">{
                        query = query.Preload(preloadField)
                }</span>
        }

        // Apply filters
        <span class="cov8" title="1">if len(filterRoot.FieldFilters) &gt; 0 </span><span class="cov8" title="1">{
                query = f.applysGorm(query, filterRoot)
        }</span>

        // Get total count before pagination
        <span class="cov8" title="1">var totalCount int64
        if err := query.Count(&amp;totalCount).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count records: %w", err)
        }</span>
        <span class="cov8" title="1">result.TotalSize = int(totalCount)
        result.TotalPage = (result.TotalSize + result.PageSize - 1) / result.PageSize

        // Check if any filters or sorts use nested fields (for table name disambiguation)
        hasNestedFields := false
        for _, filter := range filterRoot.FieldFilters </span><span class="cov8" title="1">{
                if strings.Contains(filter.Field, ".") </span><span class="cov8" title="1">{
                        hasNestedFields = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !hasNestedFields </span><span class="cov8" title="1">{
                for _, sortField := range filterRoot.SortFields </span><span class="cov8" title="1">{
                        if strings.Contains(sortField.Field, ".") </span><span class="cov8" title="1">{
                                hasNestedFields = true
                                break</span>
                        }
                }
        }

        // Get the main table name for disambiguation
        <span class="cov8" title="1">var mainTableName string
        if hasNestedFields </span><span class="cov8" title="1">{
                stmt := &amp;gorm.Statement{DB: db}
                if err := stmt.Parse(new(T)); err == nil </span><span class="cov8" title="1">{
                        mainTableName = stmt.Schema.Table
                }</span>
        }

        // Apply sorting
        <span class="cov8" title="1">if len(filterRoot.SortFields) &gt; 0 </span><span class="cov8" title="1">{
                for _, sortField := range filterRoot.SortFields </span><span class="cov8" title="1">{
                        // For simple fields, check if they exist. For nested fields, let GORM handle them.
                        if !strings.Contains(sortField.Field, ".") &amp;&amp; !f.fieldExists(sortField.Field) </span><span class="cov0" title="0">{
                                // Silently ignore non-existent simple sort fields
                                continue</span>
                        }

                        <span class="cov8" title="1">order := "ASC"
                        if sortField.Order == SortOrderDesc </span><span class="cov8" title="1">{
                                order = "DESC"
                        }</span>
                        // Normalize nested field names: "member_profile.name" -&gt; "MemberProfile.name"
                        <span class="cov8" title="1">field := sortField.Field
                        if strings.Contains(field, ".") </span><span class="cov8" title="1">{
                                parts := strings.Split(field, ".")
                                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                        parts[0] = f.toPascalCase(parts[0])
                                        // Quote identifiers to preserve case
                                        field = fmt.Sprintf(`"%s"."%s"`, parts[0], parts[1])
                                        for i := 2; i &lt; len(parts); i++ </span><span class="cov0" title="0">{
                                                field = fmt.Sprintf(`%s."%s"`, field, parts[i])
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> if mainTableName != "" </span><span class="cov8" title="1">{
                                // For non-nested fields, prefix with main table name to avoid ambiguity
                                field = fmt.Sprintf(`"%s"."%s"`, mainTableName, field)
                        }</span>
                        <span class="cov8" title="1">query = query.Order(fmt.Sprintf("%s %s", field, order))</span>
                }
        }

        // Apply pagination (0-based indexing)
        <span class="cov8" title="1">offset := result.PageIndex * result.PageSize
        query = query.Offset(int(offset)).Limit(int(result.PageSize))

        // Execute query
        var data []*T
        if err := query.Find(&amp;data).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch records: %w", err)
        }</span>

        <span class="cov8" title="1">result.Data = data
        return &amp;result, nil</span>
}

// DataGormNoPage performs database-level filtering using GORM queries without pagination.
// It generates SQL WHERE clauses based on the filter configuration and returns all matching results as a simple array.
// The db parameter can have existing WHERE conditions (e.g., organization_id, branch_id),
// and DataGormNoPage will apply additional filters from filterRoot on top of those.
//
// Example with preset conditions using struct:
//
//        type AccountTag struct {
//            OrganizationID uint
//            BranchID       uint
//        }
//        tag := &amp;AccountTag{OrganizationID: user.OrganizationID, BranchID: *user.BranchID}
//        db = filter.ApplyPresetConditions(db, tag)
//        results, err := handler.DataGormNoPage(db, filterRoot)
//
// Example with preset conditions using Where:
//
//        presetDB := db.Where("organization_id = ? AND branch_id = ?", orgID, branchID)
//        results, err := handler.DataGormNoPage(presetDB, filterRoot)
func (f *Handler[T]) DataGormNoPage(
        db *gorm.DB,
        filterRoot Root,
) ([]*T, error) <span class="cov8" title="1">{
        // Build the query - db may already have WHERE conditions, they will be preserved
        query := db.Model(new(T))

        // Auto-join related tables based on field filters and sort fields
        query = f.autoJoinRelatedTables(query, filterRoot.FieldFilters, filterRoot.SortFields)

        // Apply preloads (GORM only feature)
        if len(filterRoot.Preload) &gt; 0 </span><span class="cov8" title="1">{
                for _, preloadField := range filterRoot.Preload </span><span class="cov8" title="1">{
                        query = query.Preload(preloadField)
                }</span>
        }

        // Apply filters
        <span class="cov8" title="1">if len(filterRoot.FieldFilters) &gt; 0 </span><span class="cov8" title="1">{
                query = f.applysGorm(query, filterRoot)
        }</span>

        // Check if any filters or sorts use nested fields (for table name disambiguation)
        <span class="cov8" title="1">hasNestedFields := false
        for _, filter := range filterRoot.FieldFilters </span><span class="cov8" title="1">{
                if strings.Contains(filter.Field, ".") </span><span class="cov8" title="1">{
                        hasNestedFields = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !hasNestedFields </span><span class="cov8" title="1">{
                for _, sortField := range filterRoot.SortFields </span><span class="cov8" title="1">{
                        if strings.Contains(sortField.Field, ".") </span><span class="cov0" title="0">{
                                hasNestedFields = true
                                break</span>
                        }
                }
        }

        // Get the main table name for disambiguation
        <span class="cov8" title="1">var mainTableName string
        if hasNestedFields </span><span class="cov8" title="1">{
                stmt := &amp;gorm.Statement{DB: db}
                if err := stmt.Parse(new(T)); err == nil </span><span class="cov8" title="1">{
                        mainTableName = stmt.Schema.Table
                }</span>
        }

        // Apply sorting
        <span class="cov8" title="1">if len(filterRoot.SortFields) &gt; 0 </span><span class="cov8" title="1">{
                for _, sortField := range filterRoot.SortFields </span><span class="cov8" title="1">{
                        // For simple fields, check if they exist. For nested fields, let GORM handle them.
                        if !strings.Contains(sortField.Field, ".") &amp;&amp; !f.fieldExists(sortField.Field) </span><span class="cov0" title="0">{
                                // Silently ignore non-existent simple sort fields
                                continue</span>
                        }

                        <span class="cov8" title="1">order := "ASC"
                        if sortField.Order == SortOrderDesc </span><span class="cov8" title="1">{
                                order = "DESC"
                        }</span>
                        // Normalize nested field names: "member_profile.name" -&gt; "MemberProfile.name"
                        <span class="cov8" title="1">field := sortField.Field
                        if strings.Contains(field, ".") </span><span class="cov0" title="0">{
                                parts := strings.Split(field, ".")
                                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                        parts[0] = f.toPascalCase(parts[0])
                                        // Quote identifiers to preserve case
                                        field = fmt.Sprintf(`"%s"."%s"`, parts[0], parts[1])
                                        for i := 2; i &lt; len(parts); i++ </span><span class="cov0" title="0">{
                                                field = fmt.Sprintf(`%s."%s"`, field, parts[i])
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> if mainTableName != "" </span><span class="cov8" title="1">{
                                // For non-nested fields, prefix with main table name to avoid ambiguity
                                field = fmt.Sprintf(`"%s"."%s"`, mainTableName, field)
                        }</span>
                        <span class="cov8" title="1">query = query.Order(fmt.Sprintf("%s %s", field, order))</span>
                }
        }

        // Execute query without pagination
        <span class="cov8" title="1">var data []*T
        if err := query.Find(&amp;data).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch records: %w", err)
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

// GormNoPaginationCSV performs database-level filtering using GORM queries and returns results as CSV bytes.
// It generates SQL WHERE clauses based on the filter configuration and exports all matching results as CSV format.
// Field names are automatically used as CSV headers.
// The db parameter can have existing WHERE conditions (e.g., organization_id, branch_id),
// and GormNoPaginationCSV will apply additional filters from filterRoot on top of those.
//
// Example with preset conditions using struct:
//
//        type AccountTag struct {
//            OrganizationID uint
//            BranchID       uint
//        }
//        tag := &amp;AccountTag{OrganizationID: user.OrganizationID, BranchID: *user.BranchID}
//        db = filter.ApplyPresetConditions(db, tag)
//        csvData, err := handler.GormNoPaginationCSV(db, filterRoot)
//
// Example with preset conditions using Where:
//
//        presetDB := db.Where("organization_id = ? AND branch_id = ?", orgID, branchID)
//        csvData, err := handler.GormNoPaginationCSV(presetDB, filterRoot)
func (f *Handler[T]) GormNoPaginationCSV(
        db *gorm.DB,
        filterRoot Root,
) ([]byte, error) <span class="cov8" title="1">{
        // Use DataGormNoPage to get filtered results
        filteredData, err := f.DataGormNoPage(db, filterRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to filter data: %w", err)
        }</span>

        // Write headers using field names from the getters map
        <span class="cov8" title="1">fieldNames := make([]string, 0, len(f.getters))
        for fieldName := range f.getters </span><span class="cov8" title="1">{
                fieldNames = append(fieldNames, fieldName)
        }</span>
        <span class="cov8" title="1">sort.Strings(fieldNames) // Ensure deterministic column ordering

        // Build CSV content using encoding/csv
        var buf bytes.Buffer
        csvWriter := csv.NewWriter(&amp;buf)

        // Write headers
        if err := csvWriter.Write(fieldNames); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write CSV headers: %w", err)
        }</span>

        // Write data rows
        <span class="cov8" title="1">for _, item := range filteredData </span><span class="cov8" title="1">{
                record := make([]string, len(fieldNames))
                for i, fieldName := range fieldNames </span><span class="cov8" title="1">{
                        // Get the value using the getter for this field
                        getter := f.getters[fieldName]
                        value := getter(item)
                        record[i] = fmt.Sprintf("%v", value)
                }</span>

                <span class="cov8" title="1">if err := csvWriter.Write(record); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV record: %w", err)
                }</span>
        }

        <span class="cov8" title="1">csvWriter.Flush()
        if err := csvWriter.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV writer error: %w", err)
        }</span>

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// DataGormWithPreset is a convenience method that combines ApplyPresetConditions and DataGorm.
// It accepts preset conditions as a struct and applies them before filtering.
//
// Example usage:
//
//        type AccountTag struct {
//            OrganizationID uint `gorm:"column:organization_id"`
//            BranchID       uint `gorm:"column:branch_id"`
//        }
//
//        tag := &amp;AccountTag{
//            OrganizationID: user.OrganizationID,
//            BranchID:       *user.BranchID,
//        }
//        result, err := handler.DataGormWithPreset(db, tag, filterRoot, pageIndex, pageSize)
func (f *Handler[T]) DataGormWithPreset(
        db *gorm.DB,
        presetConditions any,
        filterRoot Root,
        pageIndex int,
        pageSize int,
) (*PaginationResult[T], error) <span class="cov8" title="1">{
        // Apply preset conditions to db
        if presetConditions != nil </span><span class="cov8" title="1">{
                db = db.Where(presetConditions)
        }</span>

        // Call regular DataGorm with the modified db
        <span class="cov8" title="1">return f.DataGorm(db, filterRoot, pageIndex, pageSize)</span>
}

// DataGormNoPageWithPreset is a convenience method that combines ApplyPresetConditions and DataGormNoPage.
// It accepts preset conditions as a struct and applies them before filtering, returning results without pagination.
//
// Example usage:
//
//        type AccountTag struct {
//            OrganizationID uint `gorm:"column:organization_id"`
//            BranchID       uint `gorm:"column:branch_id"`
//        }
//
//        tag := &amp;AccountTag{
//            OrganizationID: user.OrganizationID,
//            BranchID:       *user.BranchID,
//        }
//        results, err := handler.DataGormNoPageWithPreset(db, tag, filterRoot)
func (f *Handler[T]) DataGormNoPageWithPreset(
        db *gorm.DB,
        presetConditions any,
        filterRoot Root,
) ([]*T, error) <span class="cov8" title="1">{
        // Apply preset conditions to db
        if presetConditions != nil </span><span class="cov8" title="1">{
                db = db.Where(presetConditions)
        }</span>

        // Call DataGormNoPage with the modified db
        <span class="cov8" title="1">return f.DataGormNoPage(db, filterRoot)</span>
}

// GormNoPaginationCSVWithPreset is a convenience method that combines ApplyPresetConditions and GormNoPaginationCSV.
// It accepts preset conditions as a struct and applies them before filtering, returning results as CSV without pagination.
//
// Example usage:
//
//        type AccountTag struct {
//            OrganizationID uint `gorm:"column:organization_id"`
//            BranchID       uint `gorm:"column:branch_id"`
//        }
//
//        tag := &amp;AccountTag{
//            OrganizationID: user.OrganizationID,
//            BranchID:       *user.BranchID,
//        }
//        csvData, err := handler.GormNoPaginationCSVWithPreset(db, tag, filterRoot)
func (f *Handler[T]) GormNoPaginationCSVWithPreset(
        db *gorm.DB,
        presetConditions any,
        filterRoot Root,
) ([]byte, error) <span class="cov8" title="1">{
        // Apply preset conditions to db
        if presetConditions != nil </span><span class="cov8" title="1">{
                db = db.Where(presetConditions)
        }</span>

        // Call GormNoPaginationCSV with the modified db
        <span class="cov8" title="1">return f.GormNoPaginationCSV(db, filterRoot)</span>
}

// GormNoPaginationCSVCustom performs database-level filtering and returns results as CSV bytes.
// It uses a custom callback function to allow users to define exactly what fields and values to include in the CSV output.
// This provides full control over CSV structure and field mapping on the user side.
//
// Parameters:
//   - db: GORM database instance with any preset conditions
//   - filterRoot: filter configuration defining conditions, logic, and sorting
//   - customGetter: callback function that takes a data item and returns a map[string]any
//     where keys are column headers and values are the corresponding data
//
// Returns CSV bytes with headers from the customGetter map keys, sorted alphabetically for deterministic ordering.
//
// Example usage:
//
//        csvData, err := handler.GormNoPaginationCSVCustom(db, filterRoot, func(user *User) map[string]any {
//            return map[string]any{
//                "Full Name": user.FirstName + " " + user.LastName,
//                "Email": user.Email,
//                "Status": user.IsActive,
//                "Department": user.Department.Name, // Access nested fields if preloaded
//            }
//        })
func (f *Handler[T]) GormNoPaginationCSVCustom(
        db *gorm.DB,
        filterRoot Root,
        customGetter func(*T) map[string]any,
) ([]byte, error) <span class="cov0" title="0">{
        // Apply filters to database query
        filteredDB := f.applysGorm(db, filterRoot)

        // Apply sorting
        if len(filterRoot.SortFields) &gt; 0 </span><span class="cov0" title="0">{
                for _, sortField := range filterRoot.SortFields </span><span class="cov0" title="0">{
                        // For simple fields, check if they exist. For nested fields, let GORM handle them.
                        if !strings.Contains(sortField.Field, ".") &amp;&amp; !f.fieldExists(sortField.Field) </span><span class="cov0" title="0">{
                                // Silently ignore non-existent simple sort fields
                                continue</span>
                        }

                        <span class="cov0" title="0">order := "ASC"
                        if sortField.Order == SortOrderDesc </span><span class="cov0" title="0">{
                                order = "DESC"
                        }</span>
                        <span class="cov0" title="0">filteredDB = filteredDB.Order(fmt.Sprintf("%s %s", sortField.Field, order))</span>
                }
        }

        // Execute query to get all matching records
        <span class="cov0" title="0">var results []*T
        if err := filteredDB.Find(&amp;results).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query database: %w", err)
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                // If no data, return empty CSV
                return []byte(""), nil
        }</span>

        // Get headers from the first item using the custom getter
        <span class="cov0" title="0">firstItemFields := customGetter(results[0])

        // Sort field names for deterministic column ordering
        fieldNames := make([]string, 0, len(firstItemFields))
        for fieldName := range firstItemFields </span><span class="cov0" title="0">{
                fieldNames = append(fieldNames, fieldName)
        }</span>
        <span class="cov0" title="0">sort.Strings(fieldNames)

        // Build CSV content using encoding/csv
        var buf bytes.Buffer
        csvWriter := csv.NewWriter(&amp;buf)

        // Write headers
        if err := csvWriter.Write(fieldNames); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write CSV headers: %w", err)
        }</span>

        // Write data rows
        <span class="cov0" title="0">for _, item := range results </span><span class="cov0" title="0">{
                itemFields := customGetter(item)
                record := make([]string, len(fieldNames))

                for i, fieldName := range fieldNames </span><span class="cov0" title="0">{
                        // Get the value for this field from the custom getter result
                        if value, exists := itemFields[fieldName]; exists </span><span class="cov0" title="0">{
                                record[i] = fmt.Sprintf("%v", value)
                        }</span> else<span class="cov0" title="0"> {
                                // If field doesn't exist in this item's result, use empty string
                                record[i] = ""
                        }</span>
                }

                <span class="cov0" title="0">if err := csvWriter.Write(record); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV record: %w", err)
                }</span>
        }

        <span class="cov0" title="0">csvWriter.Flush()
        if err := csvWriter.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV writer error: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// GormNoPaginationCSVCustomWithPreset is a convenience method that combines preset conditions with GormNoPaginationCSVCustom.
// It applies preset conditions to the database query before filtering and CSV export using a custom getter function.
//
// Parameters:
//   - db: GORM database instance
//   - presetConditions: struct or map with preset WHERE conditions to apply before filtering
//   - filterRoot: filter configuration defining conditions, logic, and sorting
//   - customGetter: callback function that defines custom CSV field mapping
//
// Example usage:
//
//        type UserFilter struct {
//            OrganizationID uint
//            BranchID       uint
//        }
//
//        presetConditions := &amp;UserFilter{
//            OrganizationID: user.OrganizationID,
//            BranchID:       *user.BranchID,
//        }
//
//        csvData, err := handler.GormNoPaginationCSVCustomWithPreset(db, presetConditions, filterRoot, func(user *User) map[string]any {
//            return map[string]any{
//                "Employee ID": user.ID,
//                "Full Name":   fmt.Sprintf("%s %s", user.FirstName, user.LastName),
//                "Department":  user.Department.Name,
//            }
//        })
func (f *Handler[T]) GormNoPaginationCSVCustomWithPreset(
        db *gorm.DB,
        presetConditions any,
        filterRoot Root,
        customGetter func(*T) map[string]any,
) ([]byte, error) <span class="cov0" title="0">{
        // Apply preset conditions to db
        if presetConditions != nil </span><span class="cov0" title="0">{
                db = db.Where(presetConditions)
        }</span>

        // Call GormNoPaginationCSVCustom with the modified db
        <span class="cov0" title="0">return f.GormNoPaginationCSVCustom(db, filterRoot, customGetter)</span>
}

func (f *Handler[T]) applysGorm(db *gorm.DB, filterRoot Root) *gorm.DB <span class="cov8" title="1">{
        if len(filterRoot.FieldFilters) == 0 </span><span class="cov0" title="0">{
                return db
        }</span>

        // Check if any filters use nested fields (which trigger JOINs)
        <span class="cov8" title="1">hasNestedFields := false
        for _, filter := range filterRoot.FieldFilters </span><span class="cov8" title="1">{
                if strings.Contains(filter.Field, ".") </span><span class="cov8" title="1">{
                        hasNestedFields = true
                        break</span>
                }
        }

        // Get the main table name for disambiguation
        <span class="cov8" title="1">var mainTableName string
        if hasNestedFields </span><span class="cov8" title="1">{
                // Get table name from GORM
                stmt := &amp;gorm.Statement{DB: db}
                if err := stmt.Parse(new(T)); err == nil </span><span class="cov8" title="1">{
                        mainTableName = stmt.Schema.Table
                }</span>
        }

        <span class="cov8" title="1">if filterRoot.Logic == LogicAnd </span><span class="cov8" title="1">{
                for _, filter := range filterRoot.FieldFilters </span><span class="cov8" title="1">{
                        // For simple fields, check if they exist. For nested fields, let GORM handle them.
                        if strings.Contains(filter.Field, ".") || f.fieldExists(filter.Field) </span><span class="cov8" title="1">{
                                db = f.applyGormWithTableName(db, filter, mainTableName)
                        }</span>
                        // Silently ignore non-existent simple fields
                }
        } else<span class="cov8" title="1"> {
                var orConditions []string
                var orValues []any

                for _, filter := range filterRoot.FieldFilters </span><span class="cov8" title="1">{
                        // For simple fields, check if they exist. For nested fields, let GORM handle them.
                        if strings.Contains(filter.Field, ".") || f.fieldExists(filter.Field) </span><span class="cov8" title="1">{
                                condition, values := f.buildConditionWithTableName(filter, mainTableName)
                                if condition != "" </span><span class="cov8" title="1">{
                                        orConditions = append(orConditions, condition)
                                        orValues = append(orValues, values...)
                                }</span>
                        }
                        // Silently ignore non-existent fields
                }
                <span class="cov8" title="1">if len(orConditions) &gt; 0 </span><span class="cov8" title="1">{
                        db = db.Where(strings.Join(orConditions, " OR "), orValues...)
                }</span>
        }
        <span class="cov8" title="1">return db</span>
}

// toPascalCase converts snake_case or lowercase to PascalCase
// Examples: "member_profile" -&gt; "MemberProfile", "currency" -&gt; "Currency"
func (f *Handler[T]) toPascalCase(s string) string <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return s
        }</span>

        // Split by underscore for snake_case
        <span class="cov8" title="1">parts := strings.Split(s, "_")
        for i, part := range parts </span><span class="cov8" title="1">{
                if len(part) &gt; 0 </span><span class="cov8" title="1">{
                        parts[i] = strings.ToUpper(part[:1]) + part[1:]
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(parts, "")</span>
}

// applyGormWithTableName applies a single filter with table name disambiguation
func (f *Handler[T]) applyGormWithTableName(db *gorm.DB, filter FieldFilter, mainTableName string) *gorm.DB <span class="cov8" title="1">{
        condition, values := f.buildConditionWithTableName(filter, mainTableName)
        if condition != "" </span><span class="cov8" title="1">{
                db = db.Where(condition, values...)
        }</span>
        <span class="cov8" title="1">return db</span>
}

// buildConditionWithTableName builds SQL condition with optional table name prefix for non-nested fields
func (f *Handler[T]) buildConditionWithTableName(filter FieldFilter, mainTableName string) (string, []any) <span class="cov8" title="1">{
        field := filter.Field
        value := filter.Value

        // Check if this is a nested field
        isNestedField := strings.Contains(field, ".")

        // For nested fields, we need to normalize the relationship name to match GORM's struct field names
        // Example: "currency.currency_code" should become "Currency.currency_code"
        // We also need to quote identifiers to preserve case for PostgreSQL
        if isNestedField </span><span class="cov8" title="1">{
                parts := strings.Split(field, ".")
                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                        // Convert the first part (relationship name) to PascalCase to match struct field name
                        // GORM uses the struct field name for JOINs
                        parts[0] = f.toPascalCase(parts[0])
                        // Quote identifiers to preserve case in PostgreSQL
                        // Format: "RelationName"."field_name"
                        field = fmt.Sprintf(`"%s"."%s"`, parts[0], parts[1])
                        // For more than 2 parts, append remaining parts
                        for i := 2; i &lt; len(parts); i++ </span><span class="cov0" title="0">{
                                field = fmt.Sprintf(`%s."%s"`, field, parts[i])
                        }</span>
                }
        } else<span class="cov8" title="1"> if mainTableName != "" </span><span class="cov8" title="1">{
                // For non-nested fields, prefix with main table name to avoid ambiguity when JOINs are present
                // Quote both table and field names
                field = fmt.Sprintf(`"%s"."%s"`, mainTableName, field)
        }</span>

        <span class="cov8" title="1">switch filter.DataType </span>{
        case DataTypeNumber:<span class="cov8" title="1">
                return f.buildNumberCondition(field, filter.Mode, value)</span>
        case DataTypeText:<span class="cov8" title="1">
                return f.buildTextCondition(field, filter.Mode, value)</span>
        case DataTypeBool:<span class="cov8" title="1">
                return f.buildBoolCondition(field, filter.Mode, value)</span>
        case DataTypeDate:<span class="cov8" title="1">
                return f.buildDateCondition(field, filter.Mode, value)</span>
        case DataTypeTime:<span class="cov8" title="1">
                return f.buildTimeCondition(field, filter.Mode, value)</span>
        default:<span class="cov0" title="0">
                return "", nil</span>
        }
}

// buildNumberCondition builds SQL condition for number filters
func (f *Handler[T]) buildNumberCondition(field string, mode Mode, value any) (string, []any) <span class="cov8" title="1">{
        switch mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                num, err := parseNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%s = ?", field), []any{num}</span>
        case ModeNotEqual:<span class="cov8" title="1">
                num, err := parseNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%s != ?", field), []any{num}</span>
        case ModeGT:<span class="cov8" title="1">
                num, err := parseNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%s &gt; ?", field), []any{num}</span>
        case ModeGTE:<span class="cov8" title="1">
                num, err := parseNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%s &gt;= ?", field), []any{num}</span>
        case ModeLT:<span class="cov8" title="1">
                num, err := parseNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%s &lt; ?", field), []any{num}</span>
        case ModeLTE:<span class="cov8" title="1">
                num, err := parseNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%s &lt;= ?", field), []any{num}</span>
        case ModeRange:<span class="cov8" title="1">
                rangeVal, err := parseRangeNumber(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%s BETWEEN ? AND ?", field), []any{rangeVal.From, rangeVal.To}</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

// buildTextCondition builds SQL condition for text filters
func (f *Handler[T]) buildTextCondition(field string, mode Mode, value any) (string, []any) <span class="cov8" title="1">{
        // Handle Range mode separately since value is a Range struct, not a string
        if mode == ModeRange </span><span class="cov0" title="0">{
                rangeVal, ok := value.(Range)
                if !ok </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">fromStr, err := parseText(rangeVal.From)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">toStr, err := parseText(rangeVal.To)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s BETWEEN ? AND ?", field), []any{fromStr, toStr}</span>
        }

        // For all other modes, parse value as text
        <span class="cov8" title="1">str, err := parseText(value)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">switch mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                return fmt.Sprintf("LOWER(%s) = LOWER(?)", field), []any{str}</span>
        case ModeNotEqual:<span class="cov8" title="1">
                return fmt.Sprintf("LOWER(%s) != LOWER(?)", field), []any{str}</span>
        case ModeContains:<span class="cov8" title="1">
                return fmt.Sprintf("LOWER(%s) LIKE LOWER(?)", field), []any{"%" + str + "%"}</span>
        case ModeNotContains:<span class="cov8" title="1">
                return fmt.Sprintf("LOWER(%s) NOT LIKE LOWER(?)", field), []any{"%" + str + "%"}</span>
        case ModeStartsWith:<span class="cov8" title="1">
                return fmt.Sprintf("LOWER(%s) LIKE LOWER(?)", field), []any{str + "%"}</span>
        case ModeEndsWith:<span class="cov8" title="1">
                return fmt.Sprintf("LOWER(%s) LIKE LOWER(?)", field), []any{"%" + str}</span>
        case ModeIsEmpty:<span class="cov8" title="1">
                return fmt.Sprintf("(%s IS NULL OR %s = '')", field, field), []any{}</span>
        case ModeIsNotEmpty:<span class="cov8" title="1">
                return fmt.Sprintf("(%s IS NOT NULL AND %s != '')", field, field), []any{}</span>
        case ModeGT:<span class="cov0" title="0">
                // Support for text comparison (useful for time strings like "08:00:00")
                return fmt.Sprintf("%s &gt; ?", field), []any{str}</span>
        case ModeGTE, ModeAfter:<span class="cov0" title="0">
                // Support for text comparison (useful for time strings like "08:00:00")
                return fmt.Sprintf("%s &gt;= ?", field), []any{str}</span>
        case ModeLT, ModeBefore:<span class="cov0" title="0">
                // Support for text comparison (useful for time strings like "08:00:00")
                return fmt.Sprintf("%s &lt; ?", field), []any{str}</span>
        case ModeLTE:<span class="cov0" title="0">
                // Support for text comparison (useful for time strings like "08:00:00")
                return fmt.Sprintf("%s &lt;= ?", field), []any{str}</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

// buildBoolCondition builds SQL condition for boolean filters
func (f *Handler[T]) buildBoolCondition(field string, mode Mode, value any) (string, []any) <span class="cov8" title="1">{
        boolVal, err := parseBool(value)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">switch mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                return fmt.Sprintf("%s = ?", field), []any{boolVal}</span>
        case ModeNotEqual:<span class="cov0" title="0">
                return fmt.Sprintf("%s != ?", field), []any{boolVal}</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

// buildDateCondition builds SQL condition for date/datetime filters
func (f *Handler[T]) buildDateCondition(field string, mode Mode, value any) (string, []any) <span class="cov8" title="1">{
        switch mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                t, err := parseDateTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">hasTime := hasTimeComponent(t)
                if hasTime </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%s = ?", field), []any{t}
                }</span>
                <span class="cov8" title="1">startOfDay := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
                endOfDay := time.Date(t.Year(), t.Month(), t.Day(), 23, 59, 59, 999999999, t.Location())
                return fmt.Sprintf("%s BETWEEN ? AND ?", field), []any{startOfDay, endOfDay}</span>
        case ModeNotEqual:<span class="cov8" title="1">
                t, err := parseDateTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">hasTime := hasTimeComponent(t)
                if hasTime </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s != ?", field), []any{t}
                }</span>
                <span class="cov8" title="1">startOfDay := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
                endOfDay := time.Date(t.Year(), t.Month(), t.Day(), 23, 59, 59, 999999999, t.Location())
                return fmt.Sprintf("(%s &lt; ? OR %s &gt; ?)", field, field), []any{startOfDay, endOfDay}</span>
        case ModeGTE:<span class="cov0" title="0">
                t, err := parseDateTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">hasTime := hasTimeComponent(t)
                if hasTime </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s &gt;= ?", field), []any{t}
                }</span> else<span class="cov0" title="0"> {
                        startOfDay := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
                        return fmt.Sprintf("%s &gt;= ?", field), []any{startOfDay}
                }</span>
        case ModeLT:<span class="cov0" title="0">
                t, err := parseDateTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">hasTime := hasTimeComponent(t)
                if hasTime </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s &lt; ?", field), []any{t}
                }</span> else<span class="cov0" title="0"> {
                        startOfDay := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
                        return fmt.Sprintf("%s &lt; ?", field), []any{startOfDay}
                }</span>
        case ModeLTE:<span class="cov0" title="0">
                t, err := parseDateTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">hasTime := hasTimeComponent(t)
                if hasTime </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s &lt;= ?", field), []any{t}
                }</span> else<span class="cov0" title="0"> {
                        endOfDay := time.Date(t.Year(), t.Month(), t.Day(), 23, 59, 59, 999999999, t.Location())
                        return fmt.Sprintf("%s &lt;= ?", field), []any{endOfDay}
                }</span>
        case ModeBefore:<span class="cov8" title="1">
                t, err := parseDateTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">hasTime := hasTimeComponent(t)
                if hasTime </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s &lt; ?", field), []any{t}
                }</span> else<span class="cov8" title="1"> {
                        startOfDay := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
                        return fmt.Sprintf("%s &lt; ?", field), []any{startOfDay}
                }</span>
        case ModeAfter:<span class="cov8" title="1">
                t, err := parseDateTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">hasTime := hasTimeComponent(t)
                if hasTime </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s &gt; ?", field), []any{t}
                }</span> else<span class="cov8" title="1"> {
                        endOfDay := time.Date(t.Year(), t.Month(), t.Day(), 23, 59, 59, 999999999, t.Location())
                        return fmt.Sprintf("%s &gt; ?", field), []any{endOfDay}
                }</span>
        case ModeRange:<span class="cov8" title="1">
                rangeVal, err := parseRangeDateTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">hasTimeFrom := hasTimeComponent(rangeVal.From)
                hasTimeTo := hasTimeComponent(rangeVal.To)

                if hasTimeFrom &amp;&amp; hasTimeTo </span><span class="cov0" title="0">{
                        // Both dates have time components, use exact timestamps
                        return fmt.Sprintf("%s &gt;= ? AND %s &lt;= ?", field, field), []any{rangeVal.From, rangeVal.To}
                }</span> else<span class="cov8" title="1"> {
                        // Date-only range: include entire days from start of From day to end of To day
                        startOfFromDay := time.Date(rangeVal.From.Year(), rangeVal.From.Month(), rangeVal.From.Day(), 0, 0, 0, 0, rangeVal.From.Location())
                        endOfToDay := time.Date(rangeVal.To.Year(), rangeVal.To.Month(), rangeVal.To.Day(), 23, 59, 59, 999999999, rangeVal.To.Location())
                        return fmt.Sprintf("%s &gt;= ? AND %s &lt;= ?", field, field), []any{startOfFromDay, endOfToDay}
                }</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

// buildTimeCondition builds SQL condition for time filters
func (f *Handler[T]) buildTimeCondition(field string, mode Mode, value any) (string, []any) <span class="cov8" title="1">{
        switch mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                t, err := parseTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                // Format time as HH:MM:SS for SQLite TEXT comparison
                // Use time() function to extract time from datetime columns
                <span class="cov8" title="1">timeStr := t.Format("15:04:05")
                return fmt.Sprintf("time(%s) = ?", field), []any{timeStr}</span>
        case ModeNotEqual:<span class="cov8" title="1">
                t, err := parseTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">timeStr := t.Format("15:04:05")
                return fmt.Sprintf("time(%s) != ?", field), []any{timeStr}</span>
        case ModeGT:<span class="cov8" title="1">
                t, err := parseTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">timeStr := t.Format("15:04:05")
                return fmt.Sprintf("time(%s) &gt; ?", field), []any{timeStr}</span>
        case ModeGTE, ModeAfter:<span class="cov8" title="1">
                t, err := parseTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">timeStr := t.Format("15:04:05")
                return fmt.Sprintf("time(%s) &gt;= ?", field), []any{timeStr}</span>
        case ModeLT, ModeBefore:<span class="cov8" title="1">
                t, err := parseTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">timeStr := t.Format("15:04:05")
                return fmt.Sprintf("time(%s) &lt; ?", field), []any{timeStr}</span>
        case ModeLTE:<span class="cov0" title="0">
                t, err := parseTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">timeStr := t.Format("15:04:05")
                return fmt.Sprintf("time(%s) &lt;= ?", field), []any{timeStr}</span>
        case ModeRange:<span class="cov8" title="1">
                rangeVal, err := parseRangeTime(value)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov8" title="1">fromStr := rangeVal.From.Format("15:04:05")
                toStr := rangeVal.To.Format("15:04:05")
                return fmt.Sprintf("time(%s) BETWEEN ? AND ?", field), []any{fromStr, toStr}</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

// autoJoinRelatedTables automatically joins related tables when filters or sort fields reference nested fields
func (f *Handler[T]) autoJoinRelatedTables(db *gorm.DB, filters []FieldFilter, sortFields []SortField) *gorm.DB <span class="cov8" title="1">{
        joinedTables := make(map[string]bool)

        // Check filters for nested fields
        for _, filter := range filters </span><span class="cov8" title="1">{
                // For GORM operations, allow nested fields even if they're not in getters map
                // GORM can handle nested relations through auto-joins
                if strings.Contains(filter.Field, ".") </span><span class="cov8" title="1">{
                        parts := strings.Split(filter.Field, ".")
                        if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                // Convert snake_case/lowercase to PascalCase (e.g., "member_profile" -&gt; "MemberProfile")
                                tableName := f.toPascalCase(parts[0])
                                if !joinedTables[tableName] </span><span class="cov8" title="1">{
                                        // GORM will auto-join based on the relationship
                                        db = db.Joins(tableName)
                                        joinedTables[tableName] = true
                                }</span>
                        }
                }
        }

        // Check sort fields for nested fields
        <span class="cov8" title="1">for _, sortField := range sortFields </span><span class="cov8" title="1">{
                // For GORM operations, allow nested fields even if they're not in getters map
                // GORM can handle nested relations through auto-joins
                if strings.Contains(sortField.Field, ".") </span><span class="cov8" title="1">{
                        parts := strings.Split(sortField.Field, ".")
                        if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                                // Convert snake_case/lowercase to PascalCase
                                tableName := f.toPascalCase(parts[0])
                                if !joinedTables[tableName] </span><span class="cov8" title="1">{
                                        // GORM will auto-join based on the relationship
                                        db = db.Joins(tableName)
                                        joinedTables[tableName] = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return db</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package filter

import (
        "fmt"
        "reflect"
        "strings"
        "time"

        sanitizepkg "github.com/kennygrant/sanitize"
)

var dateTimeLayouts = []string{
        time.RFC3339,                     // "2006-01-02T15:04:05Z07:00"
        time.RFC3339Nano,                 // "2006-01-02T15:04:05.999999999Z07:00"
        time.RFC1123,                     // "Mon, 02 Jan 2006 15:04:05 MST"
        time.RFC1123Z,                    // "Mon, 02 Jan 2006 15:04:05 -0700"
        time.RFC822,                      // "02 Jan 06 15:04 MST"
        time.RFC822Z,                     // "02 Jan 06 15:04 -0700"
        time.RFC850,                      // "Monday, 02-Jan-06 15:04:05 MST"
        time.ANSIC,                       // "Mon Jan _2 15:04:05 2006"
        time.UnixDate,                    // "Mon Jan _2 15:04:05 MST 2006"
        time.RubyDate,                    // "Mon Jan 02 15:04:05 -0700 2006"
        "2006-01-02T15:04:05Z",           // ISO with Z
        "2006-01-02T15:04:05",            // ISO without zone
        "2006-01-02 15:04:05",            // Space separator
        "2006-01-02T15:04:05.999999999",  // With nanoseconds, no zone
        "01/02/2006 15:04:05",            // US MM/DD/YYYY
        "02/01/2006 15:04:05",            // EU DD/MM/YYYY
        "2006-01-02T15:04:05-07:00",      // With offset
        "Mon Jan 02 2006 15:04:05 -0700", // Variation with space and offset
        "2006/01/02 15:04:05",            // New: YYYY/MM/DD HH:MM:SS (addresses "2025/11/02 19:26:31")
        "2006/01/02T15:04:05",            // New: YYYY/MM/DDTHH:MM:SS
        "2006/01/02 15:04:05Z07:00",      // New: With offset
        "2006/01/02 15:04:05 MST",        // New: With named zone
        "2006-01-02",                     // New: Fallback for date-only as midnight
        "2006/01/02",                     // New: Slashed date-only
        "01/02/2006",                     // New: US date-only
        "02/01/2006",                     // New: EU date-only
}

var timeLayouts = []string{
        time.Kitchen,         // "3:04PM"
        "15:04:05",           // HH:MM:SS 24-hour
        "15:04",              // HH:MM
        "15:04:05.999999999", // With nanoseconds
        "3:04:05 PM",         // 12-hour with seconds
        "3:04 PM",            // 12-hour
        "15:04:05Z07:00",     // With offset
        "15:04:05 MST",       // With named zone
        "3:04:05 PM MST",     // 12-hour with named zone
        "15:04:05-07:00",     // New: Offset without Z
}

func parseNumber(value any) (float64, error) <span class="cov8" title="1">{
        // Handle nil values from nested pointers
        if value == nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">var num float64
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                num = float64(v)</span>
        case uint:<span class="cov8" title="1">
                num = float64(v)</span>
        case int8:<span class="cov0" title="0">
                num = float64(v)</span>
        case uint8:<span class="cov0" title="0">
                num = float64(v)</span>
        case int16:<span class="cov0" title="0">
                num = float64(v)</span>
        case uint16:<span class="cov0" title="0">
                num = float64(v)</span>
        case int32:<span class="cov0" title="0">
                num = float64(v)</span>
        case int64:<span class="cov0" title="0">
                num = float64(v)</span>
        case float32:<span class="cov0" title="0">
                num = float64(v)</span>
        case float64:<span class="cov8" title="1">
                num = v</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("invalid number type for field %s", value)</span>
        }
        <span class="cov8" title="1">return num, nil</span>
}

func parseText(value any) (string, error) <span class="cov8" title="1">{
        // Handle nil values from nested pointers
        if value == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">str, ok := value.(string)
        if !ok </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid text type for field %s", value)
        }</span>
        // Don't sanitize - GORM's parameterized queries handle SQL injection protection
        // Sanitizing converts spaces to hyphens which breaks text searches
        <span class="cov8" title="1">return str, nil</span>
}

func parseTime(value any) (time.Time, error) <span class="cov8" title="1">{
        // Handle nil values from nested pointers
        if value == nil </span><span class="cov0" title="0">{
                return time.Time{}, nil
        }</span>
        <span class="cov8" title="1">var t time.Time
        var err error

        switch v := value.(type) </span>{
        case time.Time:<span class="cov8" title="1">
                t = v</span>
        case string:<span class="cov8" title="1">
                var parsed bool
                for _, layout := range timeLayouts </span><span class="cov8" title="1">{
                        t, err = time.Parse(layout, v)
                        if err == nil </span><span class="cov8" title="1">{
                                parsed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !parsed </span><span class="cov8" title="1">{
                        // Fallback to datetime layouts if time-only fails
                        for _, layout := range dateTimeLayouts </span><span class="cov8" title="1">{
                                t, err = time.Parse(layout, v)
                                if err == nil </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return time.Time{}, fmt.Errorf("invalid time format: %v", v)
                        }</span>
                }
        default:<span class="cov8" title="1">
                // Try to extract time.Time from embedded structs (e.g., custom time types)
                if timeVal := reflect.ValueOf(value); timeVal.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                        // Look for an embedded time.Time field
                        if timeField := timeVal.FieldByName("Time"); timeField.IsValid() &amp;&amp; timeField.Type() == reflect.TypeOf(time.Time{}) </span><span class="cov8" title="1">{
                                t = timeField.Interface().(time.Time)
                        }</span> else<span class="cov0" title="0"> {
                                return time.Time{}, fmt.Errorf("invalid type for time: %T", value)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return time.Time{}, fmt.Errorf("invalid type for time: %T", value)
                }</span>
        }

        // Normalize to time-only in UTC
        <span class="cov8" title="1">timeOnly := time.Date(0, time.January, 1, t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), time.UTC)
        return timeOnly, nil</span>
}

func parseDateTime(value any) (time.Time, error) <span class="cov8" title="1">{
        // Handle nil values from nested pointers
        if value == nil </span><span class="cov0" title="0">{
                return time.Time{}, nil
        }</span>
        <span class="cov8" title="1">switch v := value.(type) </span>{
        case time.Time:<span class="cov8" title="1">
                return v, nil</span>
        case string:<span class="cov8" title="1">
                for _, layout := range dateTimeLayouts </span><span class="cov8" title="1">{
                        t, err := time.Parse(layout, v)
                        if err == nil </span><span class="cov8" title="1">{
                                return t, nil
                        }</span>
                }
                <span class="cov8" title="1">return time.Time{}, fmt.Errorf("invalid datetime format: %v", v)</span>
        default:<span class="cov8" title="1">
                return time.Time{}, fmt.Errorf("invalid type for datetime: %T", value)</span>
        }
}

func parseRangeNumber(value any) (RangeNumber, error) <span class="cov8" title="1">{
        var rng Range

        // Handle struct type (when used directly in Go code)
        if r, ok := value.(Range); ok </span><span class="cov8" title="1">{
                rng = r
        }</span> else<span class="cov0" title="0"> if m, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Handle map type (when parsed from JSON)
                fromVal, hasFrom := m["from"]
                toVal, hasTo := m["to"]
                if !hasFrom || !hasTo </span><span class="cov0" title="0">{
                        return RangeNumber{}, fmt.Errorf("range must have both 'from' and 'to' fields")
                }</span>
                <span class="cov0" title="0">rng = Range{From: fromVal, To: toVal}</span>
        } else<span class="cov0" title="0"> {
                return RangeNumber{}, fmt.Errorf("invalid range type for field %v (type: %T)", value, value)
        }</span>
        <span class="cov8" title="1">from, err := parseNumber(rng.From)
        if err != nil </span><span class="cov0" title="0">{
                return RangeNumber{}, err
        }</span>
        <span class="cov8" title="1">to, err := parseNumber(rng.To)
        if err != nil </span><span class="cov0" title="0">{
                return RangeNumber{}, err
        }</span>
        <span class="cov8" title="1">return RangeNumber{
                From: from,
                To:   to,
        }, nil</span>
}

func parseRangeDateTime(value any) (RangeDate, error) <span class="cov8" title="1">{
        var rng Range

        // Handle struct type (when used directly in Go code)
        if r, ok := value.(Range); ok </span><span class="cov8" title="1">{
                rng = r
        }</span> else<span class="cov8" title="1"> if m, ok := value.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                // Handle map type (when parsed from JSON)
                fromVal, hasFrom := m["from"]
                toVal, hasTo := m["to"]
                if !hasFrom || !hasTo </span><span class="cov0" title="0">{
                        return RangeDate{}, fmt.Errorf("range must have both 'from' and 'to' fields")
                }</span>
                <span class="cov8" title="1">rng = Range{From: fromVal, To: toVal}</span>
        } else<span class="cov0" title="0"> {
                return RangeDate{}, fmt.Errorf("invalid range type for field %v (type: %T)", value, value)
        }</span>
        <span class="cov8" title="1">from, err := parseDateTime(rng.From)
        if err != nil </span><span class="cov0" title="0">{
                return RangeDate{}, err
        }</span>
        <span class="cov8" title="1">to, err := parseDateTime(rng.To)
        if err != nil </span><span class="cov0" title="0">{
                return RangeDate{}, err
        }</span>
        <span class="cov8" title="1">if from.After(to) </span><span class="cov8" title="1">{
                return RangeDate{}, fmt.Errorf("range from date cannot be after to date")
        }</span>
        <span class="cov8" title="1">return RangeDate{
                From: from,
                To:   to,
        }, nil</span>
}

func parseRangeTime(value any) (RangeDate, error) <span class="cov8" title="1">{
        var rng Range

        // Handle struct type (when used directly in Go code)
        if r, ok := value.(Range); ok </span><span class="cov8" title="1">{
                rng = r
        }</span> else<span class="cov0" title="0"> if m, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Handle map type (when parsed from JSON)
                fromVal, hasFrom := m["from"]
                toVal, hasTo := m["to"]
                if !hasFrom || !hasTo </span><span class="cov0" title="0">{
                        return RangeDate{}, fmt.Errorf("range must have both 'from' and 'to' fields")
                }</span>
                <span class="cov0" title="0">rng = Range{From: fromVal, To: toVal}</span>
        } else<span class="cov0" title="0"> {
                return RangeDate{}, fmt.Errorf("invalid range type for field %v (type: %T)", value, value)
        }</span>
        <span class="cov8" title="1">from, err := parseTime(rng.From)
        if err != nil </span><span class="cov0" title="0">{
                return RangeDate{}, err
        }</span>
        <span class="cov8" title="1">to, err := parseTime(rng.To)
        if err != nil </span><span class="cov0" title="0">{
                return RangeDate{}, err
        }</span>

        // Validate that from &lt;= to
        <span class="cov8" title="1">if from.After(to) </span><span class="cov8" title="1">{
                return RangeDate{}, fmt.Errorf("range from time cannot be after to time")
        }</span>

        <span class="cov8" title="1">return RangeDate{
                From: from,
                To:   to,
        }, nil</span>
}

func parseBool(value any) (bool, error) <span class="cov8" title="1">{
        // Handle nil values from nested pointers
        if value == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov8" title="1">b, ok := value.(bool)
        if !ok </span><span class="cov8" title="1">{
                return false, fmt.Errorf("invalid boolean type for field %s", value)
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}

func hasTimeComponent(t time.Time) bool <span class="cov8" title="1">{
        if t.Hour() == 0 &amp;&amp; t.Minute() == 0 &amp;&amp; t.Second() == 0 &amp;&amp; t.Nanosecond() == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func compareValues(a, b any) int <span class="cov8" title="1">{
        // Try to parse both values to standardized types
        numA, errA := parseNumber(a)
        numB, errB := parseNumber(b)
        if errA == nil &amp;&amp; errB == nil </span><span class="cov8" title="1">{
                if numA &lt; numB </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if numA &gt; numB </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }

        <span class="cov8" title="1">strA, errA := parseText(a)
        strB, errB := parseText(b)
        if errA == nil &amp;&amp; errB == nil </span><span class="cov8" title="1">{
                return strings.Compare(strA, strB)
        }</span>

        <span class="cov8" title="1">boolA, errA := parseBool(a)
        boolB, errB := parseBool(b)
        if errA == nil &amp;&amp; errB == nil </span><span class="cov8" title="1">{
                if boolA == boolB </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">if !boolA &amp;&amp; boolB </span><span class="cov8" title="1">{
                        return -1
                }</span>
                <span class="cov8" title="1">return 1</span>
        }

        // Try datetime comparison
        <span class="cov8" title="1">timeA, errA := parseDateTime(a)
        timeB, errB := parseDateTime(b)
        if errA == nil &amp;&amp; errB == nil </span><span class="cov8" title="1">{
                if timeA.Before(timeB) </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if timeA.After(timeB) </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }

        // Try time-only comparison
        <span class="cov8" title="1">timeOnlyA, errA := parseTime(a)
        timeOnlyB, errB := parseTime(b)
        if errA == nil &amp;&amp; errB == nil </span><span class="cov8" title="1">{
                if timeOnlyA.Before(timeOnlyB) </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if timeOnlyA.After(timeOnlyB) </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }

        // Fallback: cannot compare
        <span class="cov0" title="0">return 0</span>
}

// generateGetters automatically generates field getters using reflection
func generateGetters[T any](maxDepth int) map[string]func(*T) any <span class="cov8" title="1">{
        var zero T
        t := reflect.TypeOf(zero)
        if t.Kind() == reflect.Pointer </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">getters := make(map[string]func(*T) any)
        if t.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return getters
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                field := t.Field(i)
                if !field.IsExported() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">fieldName := field.Name
                key := fieldName
                if jsonTag := field.Tag.Get("json"); jsonTag != "" </span><span class="cov8" title="1">{
                        tagValue := strings.Split(jsonTag, ",")[0]
                        if tagValue != "" &amp;&amp; tagValue != "-" </span><span class="cov8" title="1">{
                                key = tagValue
                        }</span>
                }
                <span class="cov8" title="1">lowerKey := strings.ToLower(fieldName)
                fieldIndex := i
                getter := func(v *T) any </span><span class="cov8" title="1">{
                        val := reflect.ValueOf(v)
                        if val.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                                val = val.Elem()
                        }</span>
                        <span class="cov8" title="1">return val.Field(fieldIndex).Interface()</span>
                }

                <span class="cov8" title="1">getters[key] = getter
                if key != lowerKey </span><span class="cov8" title="1">{
                        getters[lowerKey] = getter
                }</span>

                // Handle nested structs (both direct and pointer types)
                // Use configurable depth limit to avoid circular references
                <span class="cov8" title="1">fieldType := field.Type
                if fieldType.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                        fieldType = fieldType.Elem()
                }</span>
                <span class="cov8" title="1">if fieldType.Kind() == reflect.Struct &amp;&amp; maxDepth &gt; 1 </span><span class="cov8" title="1">{
                        generateNestedGetters(getters, field, fieldIndex, key, field.Type.Kind() == reflect.Pointer, 1, maxDepth)
                }</span>
        }

        <span class="cov8" title="1">return getters</span>
}

// generateNestedGetters generates getters for nested struct fields with depth limit
func generateNestedGetters[T any](
        getters map[string]func(*T) any,
        parentField reflect.StructField,
        parentIndex int,
        parentKey string,
        isPointer bool,
        depth int,
        maxDepth int,
) <span class="cov8" title="1">{
        if depth &gt; maxDepth </span><span class="cov0" title="0">{
                return // Stop at maximum depth to avoid circular references
        }</span>

        <span class="cov8" title="1">nestedType := parentField.Type
        if isPointer </span><span class="cov8" title="1">{
                nestedType = nestedType.Elem()
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; nestedType.NumField(); i++ </span><span class="cov8" title="1">{
                nestedField := nestedType.Field(i)

                if !nestedField.IsExported() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">nestedFieldName := nestedField.Name
                nestedKey := nestedFieldName

                // Check for json tag on nested field
                if jsonTag := nestedField.Tag.Get("json"); jsonTag != "" </span><span class="cov8" title="1">{
                        tagValue := strings.Split(jsonTag, ",")[0]
                        if tagValue != "" &amp;&amp; tagValue != "-" </span><span class="cov8" title="1">{
                                nestedKey = tagValue
                        }</span>
                }

                // Create composite key: parent.nested
                <span class="cov8" title="1">compositeKey := parentKey + "." + nestedKey
                compositeLowerKey := parentKey + "." + strings.ToLower(nestedFieldName)

                // Create getter for nested field
                nestedIndex := i
                nestedGetter := func(v *T) any </span><span class="cov8" title="1">{
                        val := reflect.ValueOf(v)
                        if val.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                                val = val.Elem()
                        }</span>
                        <span class="cov8" title="1">parentVal := val.Field(parentIndex)

                        // Handle pointer to struct
                        if isPointer </span><span class="cov8" title="1">{
                                if parentVal.IsNil() </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov8" title="1">parentVal = parentVal.Elem()</span>
                        }

                        <span class="cov8" title="1">return parentVal.Field(nestedIndex).Interface()</span>
                }

                <span class="cov8" title="1">getters[compositeKey] = nestedGetter
                if compositeKey != compositeLowerKey </span><span class="cov8" title="1">{
                        getters[compositeLowerKey] = nestedGetter
                }</span>

                // Recursively handle deeply nested structs with depth limit
                <span class="cov8" title="1">nestedFieldType := nestedField.Type
                isNestedPointer := false
                if nestedFieldType.Kind() == reflect.Pointer </span><span class="cov0" title="0">{
                        nestedFieldType = nestedFieldType.Elem()
                        isNestedPointer = true
                }</span>
                <span class="cov8" title="1">if nestedFieldType.Kind() == reflect.Struct &amp;&amp; depth &lt; maxDepth </span><span class="cov8" title="1">{
                        generateNestedGettersRecursive(getters, nestedField, parentIndex, nestedIndex, compositeKey, isPointer, isNestedPointer, depth+1, maxDepth)
                }</span>
        }
}

// generateNestedGettersRecursive handles deeply nested struct fields with depth limit
func generateNestedGettersRecursive[T any](getters map[string]func(*T) any, parentField reflect.StructField, rootIndex, parentIndex int, parentKey string, rootIsPointer, parentIsPointer bool, depth int, maxDepth int) <span class="cov8" title="1">{
        if depth &gt; maxDepth </span><span class="cov0" title="0">{
                return // Stop at maximum depth
        }</span>

        <span class="cov8" title="1">nestedType := parentField.Type
        if parentIsPointer </span><span class="cov0" title="0">{
                nestedType = nestedType.Elem()
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; nestedType.NumField(); i++ </span><span class="cov8" title="1">{
                nestedField := nestedType.Field(i)

                if !nestedField.IsExported() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">nestedFieldName := nestedField.Name
                nestedKey := nestedFieldName

                if jsonTag := nestedField.Tag.Get("json"); jsonTag != "" </span><span class="cov8" title="1">{
                        tagValue := strings.Split(jsonTag, ",")[0]
                        if tagValue != "" &amp;&amp; tagValue != "-" </span><span class="cov8" title="1">{
                                nestedKey = tagValue
                        }</span>
                }

                <span class="cov8" title="1">compositeKey := parentKey + "." + nestedKey
                compositeLowerKey := parentKey + "." + strings.ToLower(nestedFieldName)

                nestedIndex := i
                nestedGetter := func(v *T) any </span><span class="cov8" title="1">{
                        val := reflect.ValueOf(v)
                        if val.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                                val = val.Elem()
                        }</span>

                        // Navigate to root parent
                        <span class="cov8" title="1">rootVal := val.Field(rootIndex)
                        if rootIsPointer </span><span class="cov0" title="0">{
                                if rootVal.IsNil() </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">rootVal = rootVal.Elem()</span>
                        }

                        // Navigate to immediate parent
                        <span class="cov8" title="1">parentVal := rootVal.Field(parentIndex)
                        if parentIsPointer </span><span class="cov0" title="0">{
                                if parentVal.IsNil() </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">parentVal = parentVal.Elem()</span>
                        }

                        <span class="cov8" title="1">return parentVal.Field(nestedIndex).Interface()</span>
                }

                <span class="cov8" title="1">getters[compositeKey] = nestedGetter
                if compositeKey != compositeLowerKey </span><span class="cov8" title="1">{
                        getters[compositeLowerKey] = nestedGetter
                }</span>
        }
}

func Sanitize(input string) string <span class="cov8" title="1">{
        // Use kennygrant/sanitize package which handles:
        // - HTML/XSS sanitization
        // - SQL injection prevention
        // - Script tag removal
        // - Control character removal
        // All without manual pattern matching or regex

        // First, sanitize HTML and remove all potentially dangerous content
        sanitized := sanitizepkg.HTML(input)

        // Additionally sanitize as plain text to remove any remaining tags
        sanitized = sanitizepkg.Name(sanitized)

        // Note: GORM's parameterized queries provide the primary SQL injection protection.
        // This sanitization provides defense in depth for the application layer.

        return strings.TrimSpace(sanitized)
}</span>

// fieldExists checks if a field (including nested fields) exists in the getters map
func (f *Handler[T]) fieldExists(field string) bool <span class="cov8" title="1">{
        if f.getters == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check direct field access
        <span class="cov8" title="1">if _, exists := f.getters[field]; exists </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check lowercase version
        <span class="cov0" title="0">if _, exists := f.getters[strings.ToLower(field)]; exists </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (f *Handler[T]) compareItems(a, b *T, sortFields []SortField) int <span class="cov8" title="1">{
        for _, sortField := range sortFields </span><span class="cov8" title="1">{
                getter, exists := f.getters[sortField.Field]
                if !exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">valA := getter(a)
                valB := getter(b)
                cmp := compareValues(valA, valB)
                if sortField.Order == SortOrderDesc </span><span class="cov8" title="1">{
                        cmp = -cmp
                }</span>

                <span class="cov8" title="1">if cmp != 0 </span><span class="cov8" title="1">{
                        return cmp
                }</span>
        }
        <span class="cov8" title="1">return 0</span>
}

// escapeCSVField properly escapes a field value for CSV format
// This implementation follows RFC 4180 standard but replaces newlines with spaces for better compatibility
func escapeCSVField(field string) string <span class="cov0" title="0">{
        // Replace newlines with spaces for better single-line CSV readability
        field = strings.ReplaceAll(field, "\n", " ")
        field = strings.ReplaceAll(field, "\r", " ")
        // Clean up multiple spaces
        for strings.Contains(field, "  ") </span><span class="cov0" title="0">{
                field = strings.ReplaceAll(field, "  ", " ")
        }</span>
        <span class="cov0" title="0">field = strings.TrimSpace(field)

        // Check if field contains special characters that require quoting
        needsQuoting := strings.Contains(field, ",") ||
                strings.Contains(field, "\"")

        if needsQuoting </span><span class="cov0" title="0">{
                // Escape existing quotes by doubling them (RFC 4180 standard)
                escaped := strings.ReplaceAll(field, "\"", "\"\"")
                return "\"" + escaped + "\""
        }</span>
        <span class="cov0" title="0">return field</span>
}

// escapeCSVFieldWithOptions provides additional control over CSV field escaping
func escapeCSVFieldWithOptions(field string, replaceNewlines bool) string <span class="cov0" title="0">{
        // Option to replace newlines with spaces for better single-line readability
        if replaceNewlines </span><span class="cov0" title="0">{
                field = strings.ReplaceAll(field, "\n", " ")
                field = strings.ReplaceAll(field, "\r", " ")
                // Clean up multiple spaces
                for strings.Contains(field, "  ") </span><span class="cov0" title="0">{
                        field = strings.ReplaceAll(field, "  ", " ")
                }</span>
                <span class="cov0" title="0">field = strings.TrimSpace(field)</span>
        }

        // Check if field contains special characters that require quoting
        <span class="cov0" title="0">needsQuoting := strings.Contains(field, ",") ||
                strings.Contains(field, "\n") ||
                strings.Contains(field, "\r") ||
                strings.Contains(field, "\"")

        if needsQuoting </span><span class="cov0" title="0">{
                // Escape existing quotes by doubling them (RFC 4180 standard)
                escaped := strings.ReplaceAll(field, "\"", "\"\"")
                return "\"" + escaped + "\""
        }</span>
        <span class="cov0" title="0">return field</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package filter

import (
        "fmt"
        "strings"

        "gorm.io/gorm"
)

// Hybrid intelligently chooses between in-memory (DataQuery) and database (DataGorm)
// filtering based on estimated table size.
//
// IMPORTANT: Respects pre-existing WHERE conditions on the db parameter.
// - If DataQuery is chosen (small dataset): fetches data using existing conditions, then filters in-memory
// - If DataGorm is chosen (large dataset): combines existing conditions with filterRoot filters in SQL
//
// Example with pre-existing conditions:
//
//        db := gormDB.Where("organization_id = ? AND branch_id = ?", orgID, branchID)
//        result, err := handler.Hybrid(db, 10000, filterRoot, pageIndex, pageSize)
//        // DataQuery path: SELECT * FROM table WHERE organization_id = ? AND branch_id = ? (fetch all, filter in-memory)
//        // DataGorm path: SELECT * FROM table WHERE organization_id = ? AND branch_id = ? AND [filterRoot conditions]
func (f *Handler[T]) Hybrid(
        db *gorm.DB,
        threshold int,
        filterRoot Root,
        pageIndex int,
        pageSize int,
) (*PaginationResult[T], error) <span class="cov8" title="1">{
        // Get table name from the model
        stmt := &amp;gorm.Statement{DB: db}
        if err := stmt.Parse(new(T)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse model: %w", err)
        }</span>
        <span class="cov8" title="1">tableName := stmt.Table

        // Estimate row count based on database type
        // NOTE: Estimation uses the full table, not filtered by existing WHERE conditions
        // This is intentional - we want to estimate total table size for strategy selection
        estimatedRows, err := f.estimateTableRows(db, tableName)
        if err != nil </span><span class="cov0" title="0">{
                // If estimation fails, fall back to database filtering
                return f.DataGorm(db, filterRoot, pageIndex, pageSize)
        }</span>

        // Decide which strategy to use
        <span class="cov8" title="1">if estimatedRows &lt;= int64(threshold) </span><span class="cov8" title="1">{
                // Use in-memory filtering for better performance on small datasets
                // IMPORTANT: This respects any pre-existing WHERE conditions on db
                // Example: if db has .Where("org_id = ?", 123), only records matching that will be fetched
                var allData []*T

                // Apply preload relationships before fetching data
                queryDB := db
                for _, relation := range filterRoot.Preload </span><span class="cov8" title="1">{
                        queryDB = queryDB.Preload(relation)
                }</span>

                <span class="cov8" title="1">if err := queryDB.Find(&amp;allData).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch data for in-memory filtering: %w", err)
                }</span>
                <span class="cov8" title="1">return f.DataQuery(allData, filterRoot, pageIndex, pageSize)</span>
        }

        // Use database filtering for large datasets
        // DataGorm will combine existing WHERE conditions with filterRoot filters
        <span class="cov8" title="1">return f.DataGorm(db, filterRoot, pageIndex, pageSize)</span>
}

// DataHybridNoPage intelligently chooses between in-memory (DataQueryNoPage) and database (DataGormNoPage)
// filtering based on estimated table size, returning results without pagination.
//
// IMPORTANT: Respects pre-existing WHERE conditions on the db parameter.
// - If DataQueryNoPage is chosen (small dataset): fetches data using existing conditions, then filters in-memory
// - If DataGormNoPage is chosen (large dataset): combines existing conditions with filterRoot filters in SQL
//
// Example with pre-existing conditions:
//
//        db := gormDB.Where("organization_id = ? AND branch_id = ?", orgID, branchID)
//        results, err := handler.DataHybridNoPage(db, 10000, filterRoot)
//        // DataQueryNoPage path: SELECT * FROM table WHERE organization_id = ? AND branch_id = ? (fetch all, filter in-memory)
//        // DataGormNoPage path: SELECT * FROM table WHERE organization_id = ? AND branch_id = ? AND [filterRoot conditions]
func (f *Handler[T]) DataHybridNoPage(
        db *gorm.DB,
        threshold int,
        filterRoot Root,
) ([]*T, error) <span class="cov8" title="1">{
        // Get table name from the model
        stmt := &amp;gorm.Statement{DB: db}
        if err := stmt.Parse(new(T)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse model: %w", err)
        }</span>
        <span class="cov8" title="1">tableName := stmt.Table

        // Estimate row count based on database type
        // NOTE: Estimation uses the full table, not filtered by existing WHERE conditions
        // This is intentional - we want to estimate total table size for strategy selection
        estimatedRows, err := f.estimateTableRows(db, tableName)
        if err != nil </span><span class="cov0" title="0">{
                // If estimation fails, fall back to database filtering
                return f.DataGormNoPage(db, filterRoot)
        }</span>

        // Decide which strategy to use
        <span class="cov8" title="1">if estimatedRows &lt;= int64(threshold) </span><span class="cov8" title="1">{
                // Use in-memory filtering for better performance on small datasets
                // IMPORTANT: This respects any pre-existing WHERE conditions on db
                // Example: if db has .Where("org_id = ?", 123), only records matching that will be fetched
                var allData []*T

                // Apply preload relationships before fetching data
                queryDB := db
                for _, relation := range filterRoot.Preload </span><span class="cov8" title="1">{
                        queryDB = queryDB.Preload(relation)
                }</span>

                <span class="cov8" title="1">if err := queryDB.Find(&amp;allData).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch data for in-memory filtering: %w", err)
                }</span>
                <span class="cov8" title="1">return f.DataQueryNoPage(allData, filterRoot)</span>
        }

        // Use database filtering for large datasets
        // DataGormNoPage will combine existing WHERE conditions with filterRoot filters
        <span class="cov8" title="1">return f.DataGormNoPage(db, filterRoot)</span>
}

// HybridCSV intelligently chooses between in-memory (DataQueryNoPageCSV) and database (GormNoPaginationCSV)
// filtering based on estimated table size, returning results as CSV bytes.
//
// IMPORTANT: Respects pre-existing WHERE conditions on the db parameter.
// - If DataQueryNoPageCSV is chosen (small dataset): fetches data using existing conditions, then filters in-memory and exports to CSV
// - If GormNoPaginationCSV is chosen (large dataset): combines existing conditions with filterRoot filters in SQL and exports to CSV
//
// Example with pre-existing conditions:
//
//        db := gormDB.Where("organization_id = ? AND branch_id = ?", orgID, branchID)
//        csvData, err := handler.HybridCSV(db, 10000, filterRoot)
//        // DataQueryNoPageCSV path: SELECT * FROM table WHERE organization_id = ? AND branch_id = ? (fetch all, filter in-memory, export CSV)
//        // GormNoPaginationCSV path: SELECT * FROM table WHERE organization_id = ? AND branch_id = ? AND [filterRoot conditions] (export CSV)
func (f *Handler[T]) HybridCSV(
        db *gorm.DB,
        threshold int,
        filterRoot Root,
) ([]byte, error) <span class="cov8" title="1">{
        // Get table name from the model
        stmt := &amp;gorm.Statement{DB: db}
        if err := stmt.Parse(new(T)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse model: %w", err)
        }</span>
        <span class="cov8" title="1">tableName := stmt.Table

        // Estimate row count based on database type
        // NOTE: Estimation uses the full table, not filtered by existing WHERE conditions
        // This is intentional - we want to estimate total table size for strategy selection
        estimatedRows, err := f.estimateTableRows(db, tableName)
        if err != nil </span><span class="cov0" title="0">{
                // If estimation fails, fall back to database filtering with CSV export
                return f.GormNoPaginationCSV(db, filterRoot)
        }</span>

        // Decide which strategy to use
        <span class="cov8" title="1">if estimatedRows &lt;= int64(threshold) </span><span class="cov8" title="1">{
                // Use in-memory filtering for better performance on small datasets
                // IMPORTANT: This respects any pre-existing WHERE conditions on db
                // Example: if db has .Where("org_id = ?", 123), only records matching that will be fetched
                var allData []*T

                // Apply preload relationships before fetching data
                queryDB := db
                for _, relation := range filterRoot.Preload </span><span class="cov0" title="0">{
                        queryDB = queryDB.Preload(relation)
                }</span>

                <span class="cov8" title="1">if err := queryDB.Find(&amp;allData).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to fetch data for in-memory filtering: %w", err)
                }</span>
                <span class="cov8" title="1">return f.DataQueryNoPageCSV(allData, filterRoot)</span>
        }

        // Use database filtering for large datasets with CSV export
        // GormNoPaginationCSV will combine existing WHERE conditions with filterRoot filters
        <span class="cov8" title="1">return f.GormNoPaginationCSV(db, filterRoot)</span>
}

// HybridCSVWithPreset is a convenience method that combines preset conditions with HybridCSV.
// It accepts preset conditions as a struct and applies them before filtering, returning CSV results using hybrid strategy.
//
// Example usage:
//
//        type AccountTag struct {
//            OrganizationID uint `gorm:"column:organization_id"`
//            BranchID       uint `gorm:"column:branch_id"`
//        }
//
//        tag := &amp;AccountTag{
//            OrganizationID: user.OrganizationID,
//            BranchID:       *user.BranchID,
//        }
//        csvData, err := handler.HybridCSVWithPreset(db, tag, 10000, filterRoot)
func (f *Handler[T]) HybridCSVWithPreset(
        db *gorm.DB,
        presetConditions any,
        threshold int,
        filterRoot Root,
) ([]byte, error) <span class="cov8" title="1">{
        // Apply preset conditions to db
        if presetConditions != nil </span><span class="cov8" title="1">{
                db = db.Where(presetConditions)
        }</span>

        // Call HybridCSV with the modified db
        <span class="cov8" title="1">return f.HybridCSV(db, threshold, filterRoot)</span>
}

// HybridCSVCustom intelligently chooses between in-memory (DataQueryNoPageCSVCustom) and database (GormNoPaginationCSVCustom)
// approaches for CSV export based on estimated table size, using a custom callback function for field mapping.
// For small tables (below threshold), it uses in-memory filtering with full dataset retrieval.
// For large tables (above threshold), it uses database-level filtering to minimize memory usage.
//
// Parameters:
//   - db: GORM database instance with any preset conditions
//   - threshold: row count threshold for switching between in-memory and database strategies
//   - filterRoot: filter configuration defining conditions, logic, and sorting
//   - customGetter: callback function that defines custom CSV field mapping
//
// Strategy Selection:
//   - If estimated table rows &lt;= threshold: DataQueryNoPageCSVCustom (in-memory processing)
//   - If estimated table rows &gt; threshold: GormNoPaginationCSVCustom (database processing)
//   - If estimation fails: Falls back to GormNoPaginationCSVCustom (database processing)
//
// Example usage:
//
//        csvData, err := handler.HybridCSVCustom(db, 10000, filterRoot, func(user *User) map[string]any {
//            return map[string]any{
//                "Employee Name": fmt.Sprintf("%s %s", user.FirstName, user.LastName),
//                "Contact Email": user.Email,
//                "Department": user.Department.Name,
//                "Join Date": user.CreatedAt.Format("2006-01-02"),
//            }
//        })
func (f *Handler[T]) HybridCSVCustom(
        db *gorm.DB,
        threshold int,
        filterRoot Root,
        customGetter func(*T) map[string]any,
) ([]byte, error) <span class="cov0" title="0">{
        // Get table name from the model
        stmt := &amp;gorm.Statement{DB: db}
        if err := stmt.Parse(new(T)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse model: %w", err)
        }</span>
        <span class="cov0" title="0">tableName := stmt.Table

        // Estimate row count based on database type
        estimatedRows, err := f.estimateTableRows(db, tableName)
        if err != nil </span><span class="cov0" title="0">{
                // If estimation fails, fall back to database filtering with CSV export
                return f.GormNoPaginationCSVCustom(db, filterRoot, customGetter)
        }</span>

        <span class="cov0" title="0">if int(estimatedRows) &lt;= threshold </span><span class="cov0" title="0">{
                // Small table: use in-memory filtering with custom CSV export
                var allData []*T
                if err := db.Find(&amp;allData).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to retrieve data: %w", err)
                }</span>
                <span class="cov0" title="0">return f.DataQueryNoPageCSVCustom(allData, filterRoot, customGetter)</span>
        } else<span class="cov0" title="0"> {
                // Large table: use database filtering with custom CSV export
                return f.GormNoPaginationCSVCustom(db, filterRoot, customGetter)
        }</span>
}

// HybridCSVCustomWithPreset is a convenience method that combines preset conditions with HybridCSVCustom.
// It applies preset conditions to the database query before intelligent strategy selection and CSV export.
//
// Parameters:
//   - db: GORM database instance
//   - presetConditions: struct or map with preset WHERE conditions to apply before filtering
//   - threshold: row count threshold for strategy selection
//   - filterRoot: filter configuration defining conditions, logic, and sorting
//   - customGetter: callback function that defines custom CSV field mapping
//
// Example usage:
//
//        type OrganizationFilter struct {
//            OrganizationID uint
//        }
//
//        presetConditions := &amp;OrganizationFilter{OrganizationID: user.OrganizationID}
//
//        csvData, err := handler.HybridCSVCustomWithPreset(db, presetConditions, 10000, filterRoot, func(user *User) map[string]any {
//            return map[string]any{
//                "ID": user.ID,
//                "Name": user.Name,
//                "Email": user.Email,
//            }
//        })
func (f *Handler[T]) HybridCSVCustomWithPreset(
        db *gorm.DB,
        presetConditions any,
        threshold int,
        filterRoot Root,
        customGetter func(*T) map[string]any,
) ([]byte, error) <span class="cov0" title="0">{
        // Apply preset conditions to db
        if presetConditions != nil </span><span class="cov0" title="0">{
                db = db.Where(presetConditions)
        }</span>

        // Call HybridCSVCustom with the modified db
        <span class="cov0" title="0">return f.HybridCSVCustom(db, threshold, filterRoot, customGetter)</span>
}

// estimateTableRows returns an estimated row count for a table.
// It uses database-specific methods for fast estimation without scanning the entire table.
// NOTE: This estimates the FULL table size, ignoring any WHERE conditions on the db parameter.
func (f *Handler[T]) estimateTableRows(db *gorm.DB, tableName string) (int64, error) <span class="cov8" title="1">{
        // Get the database driver name
        dialectName := db.Name()

        type Estimate struct {
                Rows int64
        }
        var est Estimate

        // Create a fresh session without any WHERE conditions for estimation
        // We want to estimate the full table size, not filtered results
        freshDB := db.Session(&amp;gorm.Session{NewDB: true})

        switch dialectName </span>{
        case "postgres":<span class="cov0" title="0">
                // PostgreSQL: Use pg_class for instant estimation
                query := fmt.Sprintf(`
                        SELECT reltuples::BIGINT AS rows
                        FROM pg_class
                        WHERE relname = '%s'
                `, tableName)

                if err := freshDB.Raw(query).Scan(&amp;est).Error; err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("postgres estimation failed: %w", err)
                }</span>
                <span class="cov0" title="0">return est.Rows, nil</span>

        case "mysql":<span class="cov0" title="0">
                // MySQL/MariaDB: Use INFORMATION_SCHEMA
                query := `
                        SELECT TABLE_ROWS AS rows
                        FROM INFORMATION_SCHEMA.TABLES
                        WHERE TABLE_SCHEMA = DATABASE()
                          AND TABLE_NAME = ?
                `

                if err := freshDB.Raw(query, tableName).Scan(&amp;est).Error; err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("mysql estimation failed: %w", err)
                }</span>
                <span class="cov0" title="0">return est.Rows, nil</span>

        case "sqlite":<span class="cov8" title="1">
                // SQLite: Query sqlite_stat1 if available, otherwise fall back to COUNT(*)
                // First try sqlite_stat1 (if ANALYZE has been run)
                // Note: Suppress error logging since sqlite_stat1 may not exist
                query := fmt.Sprintf(`
                        SELECT stat AS rows
                        FROM sqlite_stat1
                        WHERE tbl = '%s'
                        LIMIT 1
                `, tableName)

                var statRows string
                // Use a session with disabled logging for this query to avoid "no such table" warnings
                silentDB := freshDB.Session(&amp;gorm.Session{Logger: freshDB.Logger.LogMode(1)}) // Silent mode
                err := silentDB.Raw(query).Scan(&amp;statRows).Error

                // If sqlite_stat1 exists and has data, parse it
                if err == nil &amp;&amp; statRows != "" </span><span class="cov0" title="0">{
                        // Parse the first number from the stat string
                        parts := strings.Split(statRows, " ")
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                var rowCount int64
                                if _, scanErr := fmt.Sscanf(parts[0], "%d", &amp;rowCount); scanErr == nil </span><span class="cov0" title="0">{
                                        return rowCount, nil
                                }</span>
                        }
                }

                // Fall back to COUNT(*) for SQLite
                // This works even if sqlite_stat1 doesn't exist
                <span class="cov8" title="1">var countRows int64
                if err := freshDB.Table(tableName).Count(&amp;countRows).Error; err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("sqlite count failed: %w", err)
                }</span>
                <span class="cov8" title="1">return countRows, nil</span>

        case "sqlserver":<span class="cov0" title="0">
                // SQL Server: Use system views
                query := fmt.Sprintf(`
                        SELECT SUM(p.rows) AS rows
                        FROM sys.partitions p
                        INNER JOIN sys.objects o ON p.object_id = o.object_id
                        WHERE o.name = '%s'
                          AND p.index_id IN (0, 1)
                `, tableName)

                if err := freshDB.Raw(query).Scan(&amp;est).Error; err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("sqlserver estimation failed: %w", err)
                }</span>
                <span class="cov0" title="0">return est.Rows, nil</span>

        default:<span class="cov0" title="0">
                // Unsupported database: fall back to COUNT(*)
                if err := freshDB.Table(tableName).Count(&amp;est.Rows).Error; err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("count fallback failed: %w", err)
                }</span>
                <span class="cov0" title="0">return est.Rows, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package filter

import (
        "bytes"
        "encoding/csv"
        "fmt"
        "runtime"
        "sort"
        "strings"
        "sync"
        "sync/atomic"
        "time"
)

// DataQuery performs in-memory filtering with parallel processing.
// It filters the provided data slice based on the filter configuration and returns paginated results.
func (f *Handler[T]) DataQuery(
        data []*T,
        filterRoot Root,
        pageIndex int,
        pageSize int,
) (*PaginationResult[T], error) <span class="cov8" title="1">{
        result := PaginationResult[T]{
                PageIndex: pageIndex,
                PageSize:  pageSize,
        }

        // Set defaults if not provided - use 0-based indexing
        if result.PageIndex &lt; 0 </span><span class="cov8" title="1">{
                result.PageIndex = 0
        }</span>
        <span class="cov8" title="1">if result.PageSize &lt;= 0 </span><span class="cov8" title="1">{
                result.PageSize = 30
        }</span>

        <span class="cov8" title="1">if len(data) == 0 </span><span class="cov8" title="1">{
                result.Data = data // Reuse the empty slice
                return &amp;result, nil
        }</span>

        <span class="cov8" title="1">type filterGetter struct {
                filter FieldFilter
                getter func(*T) any
        }
        valids := make([]filterGetter, 0, len(filterRoot.FieldFilters))
        for _, filter := range filterRoot.FieldFilters </span><span class="cov8" title="1">{
                if getter, exists := f.getters[filter.Field]; exists </span><span class="cov8" title="1">{
                        valids = append(valids, filterGetter{filter: filter, getter: getter})
                }</span>
        }

        <span class="cov8" title="1">numCPU := runtime.NumCPU()
        chunkSize := (len(data) + numCPU - 1) / numCPU

        // Pre-allocate result slices with exact capacity to avoid reallocations
        resultChunks := make([][]*T, numCPU)
        for i := range numCPU </span><span class="cov8" title="1">{
                resultChunks[i] = make([]*T, 0, chunkSize)
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup
        var mu sync.Mutex
        var filterErr error

        // Atomic counter for progress tracking
        var processedCount int64

        for i := range numCPU </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(workerID int) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        start := workerID * chunkSize
                        end := min(start+chunkSize, len(data))
                        if start &gt;= len(data) </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">localed := resultChunks[workerID] // Reuse pre-allocated slice

                        for _, item := range data[start:end] </span><span class="cov8" title="1">{
                                // If no filters are provided, include all items
                                if len(valids) == 0 </span><span class="cov8" title="1">{
                                        localed = append(localed, item)
                                }</span> else<span class="cov8" title="1"> {
                                        matches := filterRoot.Logic == LogicAnd
                                        for _, fg := range valids </span><span class="cov8" title="1">{
                                                value := fg.getter(item)
                                                var match bool
                                                var err error
                                                switch fg.filter.DataType </span>{
                                                case DataTypeNumber:<span class="cov8" title="1">
                                                        match, _, err = f.applyNumber(value, fg.filter)</span>
                                                case DataTypeText:<span class="cov8" title="1">
                                                        match, _, err = f.applyText(value, fg.filter)</span>
                                                case DataTypeDate:<span class="cov8" title="1">
                                                        match, _, err = f.applyDate(value, fg.filter)</span>
                                                case DataTypeBool:<span class="cov8" title="1">
                                                        match, _, err = f.applyBool(value, fg.filter)</span>
                                                case DataTypeTime:<span class="cov8" title="1">
                                                        match, _, err = f.applyTime(value, fg.filter)</span>
                                                default:<span class="cov0" title="0">
                                                        err = fmt.Errorf("unsupported data type: %s", fg.filter.DataType)</span>
                                                }
                                                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                                        mu.Lock()
                                                        if filterErr == nil </span><span class="cov8" title="1">{
                                                                filterErr = err
                                                        }</span>
                                                        <span class="cov8" title="1">mu.Unlock()
                                                        return</span>
                                                }
                                                <span class="cov8" title="1">if match != (filterRoot.Logic == LogicAnd) </span><span class="cov8" title="1">{
                                                        matches = match
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if matches </span><span class="cov8" title="1">{
                                                localed = append(localed, item) // Only append pointers, no data cloning
                                        }</span>
                                }
                                <span class="cov8" title="1">atomic.AddInt64(&amp;processedCount, 1)</span>
                        }
                        <span class="cov8" title="1">resultChunks[workerID] = localed</span>
                }(i)
        }

        <span class="cov8" title="1">wg.Wait()

        if filterErr != nil </span><span class="cov8" title="1">{
                return nil, filterErr
        }</span>

        // Calculate total size first
        <span class="cov8" title="1">totalSize := 0
        for _, chunk := range resultChunks </span><span class="cov8" title="1">{
                totalSize += len(chunk)
        }</span>

        // Pre-allocate exactly the size needed - no reallocation
        <span class="cov8" title="1">filteredData := make([]*T, 0, totalSize)
        for _, chunk := range resultChunks </span><span class="cov8" title="1">{
                filteredData = append(filteredData, chunk...) // Only copying pointers, not data
        }</span>

        // Sort after filtering
        <span class="cov8" title="1">if len(filterRoot.SortFields) &gt; 0 </span><span class="cov8" title="1">{
                sort.Slice(filteredData, func(i, j int) bool </span><span class="cov8" title="1">{
                        return f.compareItems(filteredData[i], filteredData[j], filterRoot.SortFields) &lt; 0
                }</span>)
        }

        // Apply pagination
        <span class="cov8" title="1">result.TotalSize = len(filteredData)
        result.TotalPage = (result.TotalSize + result.PageSize - 1) / result.PageSize

        // Calculate start and end indices for the requested page (0-based indexing)
        startIdx := result.PageIndex * result.PageSize
        endIdx := startIdx + result.PageSize

        // Handle out of bounds
        if startIdx &gt;= len(filteredData) </span><span class="cov8" title="1">{
                result.Data = make([]*T, 0) // Empty slice with zero allocation
                return &amp;result, nil
        }</span>

        <span class="cov8" title="1">if endIdx &gt; len(filteredData) </span><span class="cov8" title="1">{
                endIdx = len(filteredData)
        }</span>

        // Return only the requested page - this is a slice view, not a copy
        // No data cloning, just sharing pointers to the same underlying data
        <span class="cov8" title="1">result.Data = filteredData[startIdx:endIdx]
        return &amp;result, nil</span>
}

// DataQueryNoPage performs in-memory filtering with parallel processing without pagination.
// It filters the provided data slice based on the filter configuration and returns all matching results as a simple array.
func (f *Handler[T]) DataQueryNoPage(
        data []*T,
        filterRoot Root,
) ([]*T, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov8" title="1">{
                return data, nil // Return the empty slice directly
        }</span>

        <span class="cov8" title="1">type filterGetter struct {
                filter FieldFilter
                getter func(*T) any
        }
        valids := make([]filterGetter, 0, len(filterRoot.FieldFilters))
        for _, filter := range filterRoot.FieldFilters </span><span class="cov8" title="1">{
                if getter, exists := f.getters[filter.Field]; exists </span><span class="cov8" title="1">{
                        valids = append(valids, filterGetter{filter: filter, getter: getter})
                }</span>
        }

        <span class="cov8" title="1">numCPU := runtime.NumCPU()
        chunkSize := (len(data) + numCPU - 1) / numCPU

        // Pre-allocate result slices with exact capacity to avoid reallocations
        resultChunks := make([][]*T, numCPU)
        for i := range numCPU </span><span class="cov8" title="1">{
                resultChunks[i] = make([]*T, 0, chunkSize)
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup
        var mu sync.Mutex
        var filterErr error

        // Atomic counter for progress tracking
        var processedCount int64

        for i := range numCPU </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(workerID int) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        start := workerID * chunkSize
                        end := min(start+chunkSize, len(data))
                        if start &gt;= len(data) </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">localed := resultChunks[workerID] // Reuse pre-allocated slice

                        for _, item := range data[start:end] </span><span class="cov8" title="1">{
                                // If no filters are provided, include all items
                                if len(valids) == 0 </span><span class="cov8" title="1">{
                                        localed = append(localed, item)
                                }</span> else<span class="cov8" title="1"> {
                                        matches := filterRoot.Logic == LogicAnd
                                        for _, fg := range valids </span><span class="cov8" title="1">{
                                                value := fg.getter(item)
                                                var match bool
                                                var err error
                                                switch fg.filter.DataType </span>{
                                                case DataTypeNumber:<span class="cov8" title="1">
                                                        match, _, err = f.applyNumber(value, fg.filter)</span>
                                                case DataTypeText:<span class="cov8" title="1">
                                                        match, _, err = f.applyText(value, fg.filter)</span>
                                                case DataTypeDate:<span class="cov0" title="0">
                                                        match, _, err = f.applyDate(value, fg.filter)</span>
                                                case DataTypeBool:<span class="cov8" title="1">
                                                        match, _, err = f.applyBool(value, fg.filter)</span>
                                                case DataTypeTime:<span class="cov0" title="0">
                                                        match, _, err = f.applyTime(value, fg.filter)</span>
                                                default:<span class="cov0" title="0">
                                                        err = fmt.Errorf("unsupported data type: %s", fg.filter.DataType)</span>
                                                }
                                                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                                        mu.Lock()
                                                        if filterErr == nil </span><span class="cov0" title="0">{
                                                                filterErr = err
                                                        }</span>
                                                        <span class="cov0" title="0">mu.Unlock()
                                                        return</span>
                                                }
                                                <span class="cov8" title="1">if match != (filterRoot.Logic == LogicAnd) </span><span class="cov8" title="1">{
                                                        matches = match
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if matches </span><span class="cov8" title="1">{
                                                localed = append(localed, item) // Only append pointers, no data cloning
                                        }</span>
                                }
                                <span class="cov8" title="1">atomic.AddInt64(&amp;processedCount, 1)</span>
                        }
                        <span class="cov8" title="1">resultChunks[workerID] = localed</span>
                }(i)
        }

        <span class="cov8" title="1">wg.Wait()

        if filterErr != nil </span><span class="cov0" title="0">{
                return nil, filterErr
        }</span>

        // Calculate total size first
        <span class="cov8" title="1">totalSize := 0
        for _, chunk := range resultChunks </span><span class="cov8" title="1">{
                totalSize += len(chunk)
        }</span>

        // Pre-allocate exactly the size needed - no reallocation
        <span class="cov8" title="1">filteredData := make([]*T, 0, totalSize)
        for _, chunk := range resultChunks </span><span class="cov8" title="1">{
                filteredData = append(filteredData, chunk...) // Only copying pointers, not data
        }</span>

        // Sort after filtering
        <span class="cov8" title="1">if len(filterRoot.SortFields) &gt; 0 </span><span class="cov8" title="1">{
                sort.Slice(filteredData, func(i, j int) bool </span><span class="cov8" title="1">{
                        return f.compareItems(filteredData[i], filteredData[j], filterRoot.SortFields) &lt; 0
                }</span>)
        }

        <span class="cov8" title="1">return filteredData, nil</span>
}

// DataQueryNoPageCSV performs in-memory filtering with parallel processing and returns results as CSV bytes.
// It filters the provided data slice based on the filter configuration and exports all matching results as CSV format.
// Field names are automatically used as CSV headers.
func (f *Handler[T]) DataQueryNoPageCSV(
        data []*T,
        filterRoot Root,
) ([]byte, error) <span class="cov8" title="1">{
        // Use DataQueryNoPage to get filtered results
        filteredData, err := f.DataQueryNoPage(data, filterRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to filter data: %w", err)
        }</span>

        // Build CSV content using encoding/csv
        <span class="cov8" title="1">var csvBuffer strings.Builder
        csvWriter := csv.NewWriter(&amp;csvBuffer)

        // Sort field names for deterministic column ordering
        fieldNames := make([]string, 0, len(f.getters))
        for fieldName := range f.getters </span><span class="cov8" title="1">{
                fieldNames = append(fieldNames, fieldName)
        }</span>
        <span class="cov8" title="1">sort.Strings(fieldNames)

        // Write headers
        if err := csvWriter.Write(fieldNames); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write CSV headers: %w", err)
        }</span>

        // Write data rows
        <span class="cov8" title="1">for _, item := range filteredData </span><span class="cov8" title="1">{
                record := make([]string, len(fieldNames))
                for i, fieldName := range fieldNames </span><span class="cov8" title="1">{
                        // Get the value using the getter for this field
                        getter := f.getters[fieldName]
                        value := getter(item)
                        record[i] = fmt.Sprintf("%v", value)
                }</span>

                <span class="cov8" title="1">if err := csvWriter.Write(record); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV record: %w", err)
                }</span>
        }

        // Flush the writer to ensure all data is written
        <span class="cov8" title="1">csvWriter.Flush()
        if err := csvWriter.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV writer error: %w", err)
        }</span>

        <span class="cov8" title="1">return []byte(csvBuffer.String()), nil</span>
}

// DataQueryNoPageCSVCustom performs in-memory filtering with parallel processing and returns results as CSV bytes.
// It uses a custom callback function to allow users to define exactly what fields and values to include in the CSV output.
// This provides full control over CSV structure and field mapping on the user side.
//
// Parameters:
//   - data: slice of pointers to the data type T to filter
//   - filterRoot: filter configuration defining conditions, logic, and sorting
//   - customGetter: callback function that takes a data item and returns a map[string]any
//     where keys are column headers and values are the corresponding data
//
// Returns CSV bytes with headers from the customGetter map keys, sorted alphabetically for deterministic ordering.
//
// Example usage:
//
//        csvData, err := handler.DataQueryNoPageCSVCustom(users, filterRoot, func(user *User) map[string]any {
//            return map[string]any{
//                "Full Name": user.FirstName + " " + user.LastName,
//                "Email": user.Email,
//                "Status": user.IsActive,
//                "Department": user.Department.Name, // Access nested fields
//            }
//        })
func (f *Handler[T]) DataQueryNoPageCSVCustom(
        data []*T,
        filterRoot Root,
        customGetter func(*T) map[string]any,
) ([]byte, error) <span class="cov8" title="1">{
        // Use DataQueryNoPage to get filtered results
        filteredData, err := f.DataQueryNoPage(data, filterRoot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to filter data: %w", err)
        }</span>

        <span class="cov8" title="1">if len(filteredData) == 0 </span><span class="cov8" title="1">{
                // If no data, we can't determine headers, return empty CSV with no headers
                return []byte(""), nil
        }</span>

        // Get headers from the first item using the custom getter
        <span class="cov8" title="1">firstItemFields := customGetter(filteredData[0])

        // Sort field names for deterministic column ordering
        fieldNames := make([]string, 0, len(firstItemFields))
        for fieldName := range firstItemFields </span><span class="cov8" title="1">{
                fieldNames = append(fieldNames, fieldName)
        }</span>
        <span class="cov8" title="1">sort.Strings(fieldNames)

        // Build CSV content using encoding/csv
        var buf bytes.Buffer
        csvWriter := csv.NewWriter(&amp;buf)

        // Write headers
        if err := csvWriter.Write(fieldNames); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write CSV headers: %w", err)
        }</span>

        // Write data rows
        <span class="cov8" title="1">for _, item := range filteredData </span><span class="cov8" title="1">{
                itemFields := customGetter(item)
                record := make([]string, len(fieldNames))

                for i, fieldName := range fieldNames </span><span class="cov8" title="1">{
                        // Get the value for this field from the custom getter result
                        if value, exists := itemFields[fieldName]; exists </span><span class="cov8" title="1">{
                                record[i] = fmt.Sprintf("%v", value)
                        }</span> else<span class="cov0" title="0"> {
                                // If field doesn't exist in this item's result, use empty string
                                record[i] = ""
                        }</span>
                }

                <span class="cov8" title="1">if err := csvWriter.Write(record); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write CSV record: %w", err)
                }</span>
        }

        <span class="cov8" title="1">csvWriter.Flush()
        if err := csvWriter.Error(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV writer error: %w", err)
        }</span>

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// applyNumber applies a number filter and returns whether the value matches the filter
func (f *Handler[T]) applyNumber(value any, filter FieldFilter) (bool, float64, error) <span class="cov8" title="1">{
        num, err := parseNumber(value)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, err
        }</span>
        <span class="cov8" title="1">switch filter.Mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                value, err := parseNumber(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, num, err
                }</span>
                <span class="cov8" title="1">return num == value, num, nil</span>
        case ModeNotEqual:<span class="cov0" title="0">
                value, err := parseNumber(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, num, err
                }</span>
                <span class="cov0" title="0">return num != value, num, nil</span>
        case ModeContains:<span class="cov0" title="0">
                return false, num, fmt.Errorf("contains filter not supported for number field %s", filter.Field)</span>
        case ModeNotContains:<span class="cov0" title="0">
                return false, num, fmt.Errorf("not contains filter not supported for number field %s", filter.Field)</span>
        case ModeStartsWith:<span class="cov0" title="0">
                return false, num, fmt.Errorf("starts with filter not supported for number field %s", filter.Field)</span>
        case ModeEndsWith:<span class="cov0" title="0">
                return false, num, fmt.Errorf("ends with filter not supported for number field %s", filter.Field)</span>
        case ModeIsEmpty:<span class="cov0" title="0">
                return false, num, fmt.Errorf("is empty filter not supported for number field %s", filter.Field)</span>
        case ModeIsNotEmpty:<span class="cov0" title="0">
                return false, num, fmt.Errorf("is not empty filter not supported for number field %s", filter.Field)</span>
        case ModeGT:<span class="cov8" title="1">
                value, err := parseNumber(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, num, err
                }</span>
                <span class="cov8" title="1">return num &gt; value, num, nil</span>
        case ModeGTE:<span class="cov8" title="1">
                value, err := parseNumber(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, num, err
                }</span>
                <span class="cov8" title="1">return num &gt;= value, num, nil</span>
        case ModeLT:<span class="cov8" title="1">
                value, err := parseNumber(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, num, err
                }</span>
                <span class="cov8" title="1">return num &lt; value, num, nil</span>
        case ModeLTE:<span class="cov8" title="1">
                value, err := parseNumber(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, num, err
                }</span>
                <span class="cov8" title="1">return num &lt;= value, num, nil</span>
        case ModeRange:<span class="cov8" title="1">
                value, err := parseRangeNumber(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, num, err
                }</span>
                <span class="cov8" title="1">return num &gt;= value.From &amp;&amp; num &lt;= value.To, num, nil</span>
        case ModeBefore:<span class="cov0" title="0">
                return false, num, fmt.Errorf("before filter not supported for number field %s", filter.Field)</span>
        case ModeAfter:<span class="cov0" title="0">
                return false, num, fmt.Errorf("after filter not supported for number field %s", filter.Field)</span>
        default:<span class="cov0" title="0">
                return false, num, fmt.Errorf("unsupported filter mode: %s", filter.Mode)</span>
        }
}

// applyText applies a text filter and returns whether the value matches the filter
// All text comparisons are case-insensitive
func (f *Handler[T]) applyText(value any, filter FieldFilter) (bool, string, error) <span class="cov8" title="1">{
        data, err := parseText(value)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>

        // Convert to lowercase for case-insensitive comparison
        <span class="cov8" title="1">dataLower := strings.ToLower(data)

        switch filter.Mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                substr, err := parseText(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">return dataLower == strings.ToLower(substr), data, nil</span>
        case ModeNotEqual:<span class="cov8" title="1">
                substr, err := parseText(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">return dataLower != strings.ToLower(substr), data, nil</span>
        case ModeContains:<span class="cov8" title="1">
                substr, err := parseText(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">return strings.Contains(dataLower, strings.ToLower(substr)), data, nil</span>
        case ModeNotContains:<span class="cov0" title="0">
                substr, err := parseText(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov0" title="0">return !strings.Contains(dataLower, strings.ToLower(substr)), data, nil</span>
        case ModeStartsWith:<span class="cov8" title="1">
                substr, err := parseText(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">return strings.HasPrefix(dataLower, strings.ToLower(substr)), data, nil</span>
        case ModeEndsWith:<span class="cov8" title="1">
                substr, err := parseText(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">return strings.HasSuffix(dataLower, strings.ToLower(substr)), data, nil</span>
        case ModeIsEmpty:<span class="cov0" title="0">
                return data == "", data, nil</span>
        case ModeIsNotEmpty:<span class="cov0" title="0">
                return data != "", data, nil</span>
        case ModeGT:<span class="cov0" title="0">
                return false, data, fmt.Errorf("greater than filter not supported for text field %s", filter.Field)</span>
        case ModeGTE:<span class="cov0" title="0">
                return false, data, fmt.Errorf("greater than or equal filter not supported for text field %s", filter.Field)</span>
        case ModeLT:<span class="cov0" title="0">
                return false, data, fmt.Errorf("less than filter not supported for text field %s", filter.Field)</span>
        case ModeLTE:<span class="cov0" title="0">
                return false, data, fmt.Errorf("less than or equal filter not supported for text field %s", filter.Field)</span>
        case ModeRange:<span class="cov0" title="0">
                return false, data, fmt.Errorf("range filter not supported for text field %s", filter.Field)</span>
        case ModeBefore:<span class="cov0" title="0">
                return false, data, fmt.Errorf("before filter not supported for text field %s", filter.Field)</span>
        case ModeAfter:<span class="cov0" title="0">
                return false, data, fmt.Errorf("after filter not supported for text field %s", filter.Field)</span>
        default:<span class="cov0" title="0">
                return false, data, fmt.Errorf("unsupported filter mode: %s", filter.Mode)</span>
        }
}

// applyBool applies a boolean filter and returns whether the value matches the filter
func (f *Handler[T]) applyBool(value any, filter FieldFilter) (bool, bool, error) <span class="cov8" title="1">{
        data, err := parseBool(value)
        if err != nil </span><span class="cov0" title="0">{
                return false, data, err
        }</span>
        <span class="cov8" title="1">val, err := parseBool(filter.Value)
        if err != nil </span><span class="cov0" title="0">{
                return false, data, err
        }</span>

        <span class="cov8" title="1">switch filter.Mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                return data == val, data, nil</span>
        case ModeNotEqual:<span class="cov8" title="1">
                return data != val, data, nil</span>
        case ModeContains:<span class="cov0" title="0">
                return false, data, fmt.Errorf("contains filter not supported for boolean field %s", filter.Field)</span>
        case ModeNotContains:<span class="cov0" title="0">
                return false, data, fmt.Errorf("not contains filter not supported for boolean field %s", filter.Field)</span>
        case ModeStartsWith:<span class="cov0" title="0">
                return false, data, fmt.Errorf("starts with filter not supported for boolean field %s", filter.Field)</span>
        case ModeEndsWith:<span class="cov0" title="0">
                return false, data, fmt.Errorf("ends with filter not supported for boolean field %s", filter.Field)</span>
        case ModeIsEmpty:<span class="cov0" title="0">
                return false, data, fmt.Errorf("is empty filter not supported for boolean field %s", filter.Field)</span>
        case ModeIsNotEmpty:<span class="cov0" title="0">
                return false, data, fmt.Errorf("is not empty filter not supported for boolean field %s", filter.Field)</span>
        case ModeGT:<span class="cov0" title="0">
                return false, data, fmt.Errorf("greater than filter not supported for boolean field %s", filter.Field)</span>
        case ModeGTE:<span class="cov0" title="0">
                return false, data, fmt.Errorf("greater than or equal filter not supported for boolean field %s", filter.Field)</span>
        case ModeLT:<span class="cov0" title="0">
                return false, data, fmt.Errorf("less than filter not supported for boolean field %s", filter.Field)</span>
        case ModeLTE:<span class="cov0" title="0">
                return false, data, fmt.Errorf("less than or equal filter not supported for boolean field %s", filter.Field)</span>
        case ModeRange:<span class="cov0" title="0">
                return false, data, fmt.Errorf("range filter not supported for boolean field %s", filter.Field)</span>
        case ModeBefore:<span class="cov0" title="0">
                return false, data, fmt.Errorf("before filter not supported for boolean field %s", filter.Field)</span>
        case ModeAfter:<span class="cov0" title="0">
                return false, data, fmt.Errorf("after filter not supported for boolean field %s", filter.Field)</span>
        default:<span class="cov0" title="0">
                return false, data, fmt.Errorf("unsupported filter mode: %s", filter.Mode)</span>
        }
}

// applyDate applies a date filter and returns whether the value matches the filter
func (f *Handler[T]) applyDate(value any, filter FieldFilter) (bool, time.Time, error) <span class="cov8" title="1">{
        data, err := parseDateTime(value)
        if err != nil </span><span class="cov0" title="0">{
                return false, time.Time{}, err
        }</span>
        <span class="cov8" title="1">hasTime := hasTimeComponent(data)

        switch filter.Mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                filterVal, err := parseDateTime(filter.Value)
                if err != nil </span><span class="cov8" title="1">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">if hasTime </span><span class="cov8" title="1">{
                        return data.Equal(filterVal), data, nil
                }</span> else<span class="cov8" title="1"> {
                        startOfDay := time.Date(data.Year(), data.Month(), data.Day(), 0, 0, 0, 0, data.Location())
                        endOfDay := time.Date(data.Year(), data.Month(), data.Day(), 23, 59, 59, 999999999, data.Location())
                        return !filterVal.Before(startOfDay) &amp;&amp; !filterVal.After(endOfDay), data, nil
                }</span>
        case ModeNotEqual:<span class="cov8" title="1">
                filterVal, err := parseDateTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">if hasTime </span><span class="cov8" title="1">{
                        return !data.Equal(filterVal), data, nil
                }</span> else<span class="cov0" title="0"> {
                        startOfDay := time.Date(data.Year(), data.Month(), data.Day(), 0, 0, 0, 0, data.Location())
                        endOfDay := time.Date(data.Year(), data.Month(), data.Day(), 23, 59, 59, 999999999, data.Location())
                        return filterVal.Before(startOfDay) || filterVal.After(endOfDay), data, nil
                }</span>
        case ModeContains:<span class="cov0" title="0">
                return false, data, fmt.Errorf("contains filter not supported for date field %s", filter.Field)</span>
        case ModeNotContains:<span class="cov0" title="0">
                return false, data, fmt.Errorf("not contains filter not supported for date field %s", filter.Field)</span>
        case ModeStartsWith:<span class="cov0" title="0">
                return false, data, fmt.Errorf("starts with filter not supported for date field %s", filter.Field)</span>
        case ModeEndsWith:<span class="cov0" title="0">
                return false, data, fmt.Errorf("ends with filter not supported for date field %s", filter.Field)</span>
        case ModeIsEmpty:<span class="cov0" title="0">
                return false, data, fmt.Errorf("is empty filter not supported for date field %s", filter.Field)</span>
        case ModeIsNotEmpty:<span class="cov0" title="0">
                return false, data, fmt.Errorf("is not empty filter not supported for date field %s", filter.Field)</span>
        case ModeGT:<span class="cov0" title="0">
                return false, data, fmt.Errorf("greater than filter not supported for date field %s", filter.Field)</span>
        case ModeGTE:<span class="cov8" title="1">
                filterVal, err := parseDateTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">if hasTime </span><span class="cov0" title="0">{
                        return data.Equal(filterVal) || data.After(filterVal), data, nil
                }</span> else<span class="cov8" title="1"> {
                        startOfDay := time.Date(filterVal.Year(), filterVal.Month(), filterVal.Day(), 0, 0, 0, 0, filterVal.Location())
                        return data.Equal(startOfDay) || data.After(startOfDay), data, nil
                }</span>
        case ModeLT:<span class="cov0" title="0">
                filterVal, err := parseDateTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov0" title="0">if hasTime </span><span class="cov0" title="0">{
                        return data.Before(filterVal), data, nil
                }</span> else<span class="cov0" title="0"> {
                        startOfDay := time.Date(filterVal.Year(), filterVal.Month(), filterVal.Day(), 0, 0, 0, 0, filterVal.Location())
                        return data.Before(startOfDay), data, nil
                }</span>
        case ModeLTE:<span class="cov8" title="1">
                filterVal, err := parseDateTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">if hasTime </span><span class="cov0" title="0">{
                        return data.Equal(filterVal) || data.Before(filterVal), data, nil
                }</span> else<span class="cov8" title="1"> {
                        endOfDay := time.Date(filterVal.Year(), filterVal.Month(), filterVal.Day(), 23, 59, 59, 999999999, filterVal.Location())
                        return data.Equal(endOfDay) || data.Before(endOfDay), data, nil
                }</span>
        case ModeRange:<span class="cov8" title="1">
                rangeVal, err := parseRangeDateTime(filter.Value)
                if err != nil </span><span class="cov8" title="1">{
                        return false, data, err
                }</span>

                // Check if filter range values have time components
                <span class="cov8" title="1">hasTimeFrom := hasTimeComponent(rangeVal.From)
                hasTimeTo := hasTimeComponent(rangeVal.To)

                if hasTimeFrom &amp;&amp; hasTimeTo </span><span class="cov8" title="1">{
                        // Both range boundaries have time - do exact timestamp comparison
                        return !data.Before(rangeVal.From) &amp;&amp; !data.After(rangeVal.To), data, nil
                }</span> else<span class="cov8" title="1"> {
                        // Date-only range - compare against full day boundaries
                        startOfFromDay := time.Date(rangeVal.From.Year(), rangeVal.From.Month(), rangeVal.From.Day(), 0, 0, 0, 0, rangeVal.From.Location())
                        endOfToDay := time.Date(rangeVal.To.Year(), rangeVal.To.Month(), rangeVal.To.Day(), 23, 59, 59, 999999999, rangeVal.To.Location())
                        return !data.Before(startOfFromDay) &amp;&amp; !data.After(endOfToDay), data, nil
                }</span>
        case ModeBefore:<span class="cov8" title="1">
                filterVal, err := parseDateTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">if hasTime </span><span class="cov8" title="1">{
                        return data.Before(filterVal), data, nil
                }</span> else<span class="cov8" title="1"> {
                        startOfDay := time.Date(filterVal.Year(), filterVal.Month(), filterVal.Day(), 0, 0, 0, 0, filterVal.Location())
                        return data.Before(startOfDay), data, nil
                }</span>
        case ModeAfter:<span class="cov8" title="1">
                filterVal, err := parseDateTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">if hasTime </span><span class="cov8" title="1">{
                        return data.After(filterVal), data, nil
                }</span> else<span class="cov8" title="1"> {
                        // After the end of the day
                        endOfDay := time.Date(filterVal.Year(), filterVal.Month(), filterVal.Day(), 23, 59, 59, 999999999, filterVal.Location())
                        return data.After(endOfDay), data, nil
                }</span>
        default:<span class="cov0" title="0">
                return false, data, fmt.Errorf("unsupported filter mode: %s", filter.Mode)</span>
        }
}

// applyTime applies a time filter and returns whether the value matches the filter
func (f *Handler[T]) applyTime(value any, filter FieldFilter) (bool, time.Time, error) <span class="cov8" title="1">{
        data, err := parseTime(value)
        if err != nil </span><span class="cov0" title="0">{
                return false, time.Time{}, err
        }</span>
        <span class="cov8" title="1">switch filter.Mode </span>{
        case ModeEqual:<span class="cov8" title="1">
                filterVal, err := parseTime(filter.Value)
                if err != nil </span><span class="cov8" title="1">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">return data.Equal(filterVal), data, nil</span>

        case ModeNotEqual:<span class="cov0" title="0">
                filterVal, err := parseTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov0" title="0">return !data.Equal(filterVal), data, nil</span>

        case ModeGTE, ModeAfter:<span class="cov8" title="1">
                filterVal, err := parseTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">return !data.Before(filterVal), data, nil</span>

        case ModeLTE:<span class="cov0" title="0">
                filterVal, err := parseTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov0" title="0">return !data.After(filterVal), data, nil</span>

        case ModeLT, ModeBefore:<span class="cov8" title="1">
                filterVal, err := parseTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">return data.Before(filterVal), data, nil</span>

        case ModeGT:<span class="cov0" title="0">
                filterVal, err := parseTime(filter.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return false, data, err
                }</span>
                <span class="cov0" title="0">return data.After(filterVal), data, nil</span>

        case ModeRange:<span class="cov8" title="1">
                rangeVal, err := parseRangeTime(filter.Value)
                if err != nil </span><span class="cov8" title="1">{
                        return false, data, err
                }</span>
                <span class="cov8" title="1">return !data.Before(rangeVal.From) &amp;&amp; !data.After(rangeVal.To), data, nil</span>

        case ModeContains, ModeNotContains, ModeStartsWith, ModeEndsWith,
                ModeIsEmpty, ModeIsNotEmpty:<span class="cov0" title="0">
                return false, data, fmt.Errorf("filter mode %s not supported for time field %s", filter.Mode, filter.Field)</span>

        default:<span class="cov0" title="0">
                return false, data, fmt.Errorf("unsupported filter mode: %s", filter.Mode)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
